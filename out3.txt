#include "stdafx.h"
#include "atom_struct.h"
#include "NB.h"

  //ATOM NODE DEFINITIONS#########################################################
  //first value is the center node. residues marked with * use commonCB.
  //common core atoms
  vector<string> commonCA =  {"CA","C","CB","N"};
  vector<string> commonO =   {"O","C"};
  vector<string> commonOXT = {"OXT","C"};
  vector<string> commonCB =  {"CB","CG"};
  //positive charges
  //arginine nodes
  vector<string> argCG = {"CG","CB","CD"};
  vector<string> argNE = {"NE","CD","CZ"};
  vector<string> argNH = {"CZ","NH1","NH2"};
  //histidine nodes*
  vector<string> hisCG =  {"CG","ND1","CD2"};
  vector<string> hisCE1 = {"CE1","ND1","NE2"};
  vector<string> hisCD2 = {"CD2","NE2","CG"};
  //lysine nodes*
  vector<string> lysCG = {"CG","CD","CB"};
  vector<string> lysCE = {"CE","CD","NZ"};
  //negative charges
  //aspartic acid nodes*
  vector<string> aspCG = {"CG","OD1","OD2"};
  //glutamic acid nodes*
  vector<string> gluCG = {"CG","CD"};
  vector<string> gluCD = {"CD","OE1","OE2"};
  //polar uncharged
  //serine
  vector<string> serCB = {"CB","OG"};
  //threonine
  vector<string> thrCB = {"CB","CG2","OG1"};
  //asparagine*
  vector<string> asnCG = {"CG","ND2","OD1"};
  //glutamine*
  vector<string> glnCG = {"CG","CD"};
  vector<string> glnCD = {"CD","OE1","NE2"};
  //specials
  //Cysteine
  vector<string> cysCB = {"CB","SG"};
  //Glycine
  vector<string> glyCA = {"CA","N","C"};
  //Proline*
  vector<string> proCG = {"CG","CB","CD"};
  vector<string> proCD = {"CD","N"};
  //Alanine
  //only common
  //Isoleucine
  vector<string> ileCB =  {"CB","CG2","CG1"};
  vector<string> ileCG1 = {"CG1","CD1"};
  //leucine*
  vector<string> leuCG = {"CG","CD1","CD2"};
  //methionine*
  vector<string> metSD = {"SD","CG","CE"};
  //phenylalanine*
  vector<string> pheCG =  {"CG","CD1","CD2"};
  vector<string> pheCE1 = {"CE1","CD1","CZ"};
  vector<string> pheCE2 = {"CE2","CD2","CZ"};
  //tryptophan*
  vector<string> trpCG =  {"CG","CD1","CD2"};
  vector<string> trpNE1 = {"NE1","CD1","CE2"};
  vector<string> trpCE2 = {"CE2","CD2","CZ2"};
  vector<string> trpCH2 = {"CH2","CZ2","CZ3"};
  vector<string> trpCE3 = {"CE3","CD2","CZ3"};
  //tyrosine*
  vector<string> tyrCG =  {"CG","CD1","CD2"};
  vector<string> tyrCE1 = {"CE1","CD1","CZ"};
  vector<string> tyrCE2 = {"CE2","CD2","CZ"};
  vector<string> tyrCZ =  {"CZ","OH"};
  //valine
  vector<string> valCB = {"CB","CG1","CG2"};

  //DNA/RNA definitions
  //core ribose atoms
  vector<string> commonRC1 = {"C1'","C2'","O4'"};
  vector<string> commonRC2 = {"C2'","C1'","C3'","O2'"};
  vector<string> commonRC3 = {"C3'","C2'","C4'","O3'"};
  vector<string> commonRC4 = {"C4'","C3'","O4'"};
  vector<string> commonRC5 = {"C5'","O5'","C4'"};
  vector<string> commonRP =  {"P","O5'","OP1","OP2","OP3"};
  //Adenine base for RNA and DNA
  vector<string> A_N9 = {"N9","C1'","C4","C8"};
  vector<string> A_N7 = {"N7","C8","C5"};
  vector<string> A_C2 = {"C2","N1","N3"};
  vector<string> A_C4 = {"C4","C5","N3"};
  vector<string> A_C6 = {"C6","C5","N1","N6"};
  //Guanine base for RNA and DNA
  vector<string> G_N9 = {"N9","C1'","C4","C8"};
  vector<string> G_N7 = {"N7","C8","C5"};
  vector<string> G_C2 = {"C2","N1","N2","N3"};
  vector<string> G_C4 = {"C4","N3","N9"};
  vector<string> G_C6 = {"C6","C5","N1","O6"};
  //Thymine base for RNA and DNA
  vector<string> T_N1 = {"N1","C1'","C2","C6"};
  vector<string> T_C5 = {"C5","C4","C6","C7"};
  vector<string> T_C4 = {"C4","N3","C5","O4"};
  vector<string> T_C2 = {"C2","N1","N3","O2"};
  //Cytosine base for RNA and DNA
  vector<string> C_N1 = {"N1","C1'","C2","C6"};
  vector<string> C_C5 = {"C5","C4","C6"};
  vector<string> C_C4 = {"C4","N3","C5","N4"};
  vector<string> C_C2 = {"C2","N1","N3","O2"};
  //END ATOM NODE DEFINITIONS###################################################


vector<vector<string>>
NB_GenPerm(vector<string>& array){
  auto l = array.size();
  vector<vector<string> > result;
  for (uint32 i = 1; i < l; i++){
    vector<string> p1 = {array[0],array[i]};
    vector<string> p2 = {array[i],array[0]};
    result.push_back(p1);
    result.push_back(p2);
  }
  return result;
}

bool
NB_IsBonded(uint32               i,
            uint32               j,
            vector<atom_struct>& pdb){

  auto& atom_i = pdb[i];
  auto& atom_j = pdb[j];
  float S_S_dist = 2.1;
  //##########################################################################
  int res_d = atom_i.RESI - atom_j.RESI;

  //cases between adjacent residues/nucleotides
  if (res_d == 1 && atom_i.CHAIN == atom_j.CHAIN){
    //bond N terminal to C terminal in proteins
    if(atom_i.MOL_TYPE == "PROTEIN" && atom_j.MOL_TYPE == "PROTEIN" &&
       atom_i.NAME == "N" && atom_j.NAME == "C"){
      return true;
    }
    //bond P terminal to O3' terminal in RNA/DNA
    if(((atom_i.MOL_TYPE == "RNA" && atom_j.MOL_TYPE == "RNA") ||
        (atom_i.MOL_TYPE == "DNA" && atom_j.MOL_TYPE == "DNA")) &&
       atom_i.NAME == "P" && atom_j.NAME == "O3'" ){
      return true;
    }
  }

  if (res_d == -1 && atom_i.CHAIN == atom_j.CHAIN){
    //bond N terminal to C terminal in proteins
    if(atom_i.MOL_TYPE == "PROTEIN" && atom_j.MOL_TYPE == "PROTEIN" &&
       atom_i.NAME == "C" && atom_j.NAME == "N"){
      return true;
    }
    //bond P terminal to O3' terminal in RNA/DNA
    if(((atom_i.MOL_TYPE == "RNA" && atom_j.MOL_TYPE == "RNA") ||
       (atom_i.MOL_TYPE == "DNA" && atom_j.MOL_TYPE == "DNA")) &&
       atom_i.NAME == "O3'" && atom_j.NAME == "P"){
      return true;
    }
  }

  //sulfur bonds, will fail if there are many sulfur bonds close together
  if((atom_i.MOL_TYPE == "PROTEIN" && atom_j.MOL_TYPE == "PROTEIN") &&
    atom_i.NAME == "SG" && atom_j.NAME == "SG"){
    if (atom_i.DISTANCES.count(j) && atom_i.DISTANCES[j] <= S_S_dist) return true;
    else return false;
  }
  //cout << "NB0" << atom_i.print() << "\n";
  //cases inside residues/nucleotides
  if (res_d == 0 &&
      atom_i.RESI == atom_j.RESI &&
      atom_i.CHAIN == atom_j.CHAIN){
    if(atom_i.MOL_TYPE == "PROTEIN" && atom_j.MOL_TYPE == "PROTEIN"){
    //common core atoms
      vector<vector<vector<string>>> CommonAtoms = { NB_GenPerm(commonCA),
                                                     NB_GenPerm(commonO),
                                                     NB_GenPerm(commonOXT) };
      for (auto& set : CommonAtoms){
        for(auto& pair : set){
          if(atom_i.NAME == pair[0] && atom_j.NAME == pair[1]) return true;
        }
      }

      if(atom_i.RESN == "ARG" && atom_j.RESN == "ARG"){
        CommonAtoms = { NB_GenPerm(argCG),
                        NB_GenPerm(argNE),
                        NB_GenPerm(argNH) };
      }

      if(atom_i.RESN == "HIS" && atom_j.RESN == "HIS"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(hisCG),
                        NB_GenPerm(hisCE1),
                        NB_GenPerm(hisCD2) };
      }
      if(atom_i.RESN == "LYS" && atom_j.RESN == "LYS"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(lysCG),
                        NB_GenPerm(lysCE)};
      }
      if(atom_i.RESN == "ASP" && atom_j.RESN == "ASP"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(aspCG)};
      }
      if(atom_i.RESN == "GLU" && atom_j.RESN == "GLU"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(gluCG),
                        NB_GenPerm(gluCD)};
      }
      if(atom_i.RESN == "SER" && atom_j.RESN == "SER"){
        CommonAtoms = { NB_GenPerm(serCB)};
      }
      if(atom_i.RESN == "THR" && atom_j.RESN == "THR"){
        CommonAtoms = { NB_GenPerm(thrCB)};
      }
      if(atom_i.RESN == "ASN" && atom_j.RESN == "ASN"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(asnCG)};
      }
      if(atom_i.RESN == "GLN" && atom_j.RESN == "GLN"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(glnCG),
                        NB_GenPerm(glnCD)};
      }
      if(atom_i.RESN == "CYS" && atom_j.RESN == "CYS"){
        CommonAtoms = { NB_GenPerm(cysCB) };
      }
      if(atom_i.RESN == "GLY" && atom_j.RESN == "GLY"){
        CommonAtoms = { NB_GenPerm(glyCA) };
      }
      if(atom_i.RESN == "PRO" && atom_j.RESN == "PRO"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(proCG),
                        NB_GenPerm(proCD)};
      }
      if(atom_i.RESN == "ALA" && atom_j.RESN == "ALA"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(gluCG),
                        NB_GenPerm(gluCD)};
      }
      if(atom_i.RESN == "ILE" && atom_j.RESN == "ILE"){
        CommonAtoms = { NB_GenPerm(ileCB),
                        NB_GenPerm(ileCG1)};
      }

      if(atom_i.RESN == "LEU" && atom_j.RESN == "LEU"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(leuCG)
        };
      }
      if(atom_i.RESN == "MET" && atom_j.RESN == "MET"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(metSD)};
      }
      if(atom_i.RESN == "PHE" && atom_j.RESN == "PHE"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(pheCG),
                        NB_GenPerm(pheCE1),
                        NB_GenPerm(pheCE2)};
      }
      if(atom_i.RESN == "TRP" && atom_j.RESN == "TRP"){
        CommonAtoms = { NB_GenPerm(commonCB),
                        NB_GenPerm(trpCG),
                        NB_GenPerm(trpNE1),
                        NB_GenPerm(trpCE2),
                        NB_GenPerm(trpCH2),
                        NB_GenPerm(trpCE3) };
      }
      if(atom_i.RESN == "TYR" && atom_j.RESN == "TYR"){
        CommonAtoms = {NB_GenPerm(commonCB),
                       NB_GenPerm(tyrCG),
                       NB_GenPerm(tyrCE1),
                       NB_GenPerm(tyrCE2),
                       NB_GenPerm(tyrCZ)};
      }
      if(atom_i.RESN == "VAL" && atom_j.RESN == "VAL"){
        CommonAtoms = { NB_GenPerm(valCB) };
      }

      for (auto& set : CommonAtoms){
        for(auto& pair : set){
          if(atom_i.NAME == pair[0] && atom_j.NAME == pair[1]) return true;
        }
      }
    }
    //cout << "NB1" << atom_i.print() << " " << "|" <<atom_i.MOL_TYPE << "|" << "\n";
    if((atom_i.MOL_TYPE == "RNA" && atom_j.MOL_TYPE == "RNA") ||
       (atom_i.MOL_TYPE == "DNA" && atom_j.MOL_TYPE == "DNA")){
      //common core atoms
      vector<vector<vector<string>>> CommonAtoms = { NB_GenPerm(commonRC1),
                                                     NB_GenPerm(commonRC2),
                                                     NB_GenPerm(commonRC3),
                                                     NB_GenPerm(commonRC4),
                                                     NB_GenPerm(commonRC5),
                                                     NB_GenPerm(commonRP) };
      for (auto& set : CommonAtoms){
        for(auto& pair : set){
          if(atom_i.NAME == pair[0] && atom_j.NAME == pair[1]) return true;
        }
      }
      if((atom_i.RESN == "DA" || atom_i.RESN == "A" )&&
         (atom_j.RESN == "DA" || atom_j.RESN == "A")){
        CommonAtoms = { NB_GenPerm(commonRC1),
                        NB_GenPerm(commonRC2),
                        NB_GenPerm(commonRC3),
                        NB_GenPerm(commonRC4),
                        NB_GenPerm(commonRC5),
                        NB_GenPerm(commonRP),
                        NB_GenPerm(A_N9),
                        NB_GenPerm(A_N7),
                        NB_GenPerm(A_C2),
                        NB_GenPerm(A_C4),
                        NB_GenPerm(A_C6)};
      }
      if((atom_i.RESN == "DG" || atom_i.RESN == "G" )&&
         (atom_j.RESN == "DG" || atom_j.RESN == "G")){
        CommonAtoms = { NB_GenPerm(commonRC1),
                        NB_GenPerm(commonRC2),
                        NB_GenPerm(commonRC3),
                        NB_GenPerm(commonRC4),
                        NB_GenPerm(commonRC5),
                        NB_GenPerm(commonRP),
                        NB_GenPerm(G_N9),
                        NB_GenPerm(G_N7),
                        NB_GenPerm(G_C2),
                        NB_GenPerm(G_C4),
                        NB_GenPerm(G_C6)};
      }
      if((atom_i.RESN == "DT" || atom_i.RESN == "T" )&&
         (atom_j.RESN == "DT" || atom_j.RESN == "T")){
        CommonAtoms = { NB_GenPerm(commonRC1),
                        NB_GenPerm(commonRC2),
                        NB_GenPerm(commonRC3),
                        NB_GenPerm(commonRC4),
                        NB_GenPerm(commonRC5),
                        NB_GenPerm(commonRP),
                        NB_GenPerm(T_N1),
                        NB_GenPerm(T_C5),
                        NB_GenPerm(T_C4),
                        NB_GenPerm(T_C2)};
      }
      if((atom_i.RESN == "DC" || atom_i.RESN == "C" )&&
         (atom_j.RESN == "DC" || atom_j.RESN == "C")){
        CommonAtoms = { NB_GenPerm(commonRC1),
                        NB_GenPerm(commonRC2),
                        NB_GenPerm(commonRC3),
                        NB_GenPerm(commonRC4),
                        NB_GenPerm(commonRC5),
                        NB_GenPerm(commonRP),
                        NB_GenPerm(C_N1),
                        NB_GenPerm(C_C5),
                        NB_GenPerm(C_C4),
                        NB_GenPerm(C_C2)};
      }
      for (auto& set : CommonAtoms){
        for(auto& pair : set){
          if(atom_i.NAME == pair[0] && atom_j.NAME == pair[1]) return true;
        }
      }
    }
  }
  return false;
}

void
NB_LinkPDB(vector<atom_struct>&   pdb){
  auto l = pdb.size();
  for (uint32 i = 0; i < l; i++){
    auto& atom_i = pdb[i];
    for (uint32 j = i + 1; j < l; j++ ){
      auto& atom_j = pdb[j];
      if (NB_IsBonded(i,j,pdb)){
        atom_i.BONDED.push_back(j);
        atom_j.BONDED.push_back(i);
      }
    }
  }
}

vector<vector<uint32>>
NB_GetBonded(uint32               i,
             uint32               D,
             vector<atom_struct>& pdb){
  //cout << "Depth " << D << "\n";
  uint32 depth = 0;
  int depth_inc = 1;
  int n_depth_inc = 0;
  queue<uint32> Nodes;
  vector<vector<uint32>> result;
  vector<char> walked(pdb.size(),false);

  result.resize(D+1);
  Nodes.push(i);
  walked[i] = true;
  while(!Nodes.empty()){
    uint32 cur = Nodes.front();
    Nodes.pop();
    n_depth_inc += pdb[cur].BONDED.size();
    for (uint32 child : pdb[cur].BONDED){
      if(!walked[child]){
        result[depth].push_back(child);
      }
      else n_depth_inc--;
    }

    if ( --depth_inc == 0){
      if(++depth > D) break;
      depth_inc = n_depth_inc;
      n_depth_inc = 0;
    }

    for (uint32 child : pdb[cur].BONDED){
      if(!walked[child]){
        walked[child] = true;
        Nodes.push(child);
      }
    }
  }
  return result;
}

void
NB_RemoveBonded(vector<atom_struct>& pdb,
                int                  nb,
                vector<char>&        Imtrx){
  if (nb == -1) return;
  auto l = pdb.size();
  for (uint32 i = 0; i < l; i++){
    auto list = NB_GetBonded(i,nb,pdb);
    for (auto& depth : list){
      for (uint32 j : depth){
        Imtrx[i + j * l] = false;
      }
    }
  }
}
vector<vector<string>>
NB_GenPerm(vector<string>&); //Generates permutations of a N length array, with the
                             //first element being the center

//checks if atoms are bonded
bool
NB_IsBonded(uint32,                // atom i
            uint32,                // atom j
            vector<atom_struct>&); // atom vector

//Links bonded atoms in a atom vector
void
NB_LinkPDB(vector<atom_struct>&);

//Gets all bonded and non-bonded atoms up to a certain depth.
vector<vector<uint32>>
NB_GetBonded(uint32,                // root atom
             uint32,                // max depth 0: directly bonded atoms
             vector<atom_struct>&); // structure


void
NB_RemoveBonded(vector<atom_struct>&,   //pdb
                int,                    //select bonding depth
                vector<char>&);         //interaction matrix#include "stdafx.h"
#include "atom_struct.h"
#include "NonEffective.h"

void
NE_RemoveNonEffective(vector<atom_struct>& pdb,   //structure
                      float               o,     //angle
                      vector<char>&        Imtrx){//interaction matrix
  if (o == 180.0) return;
  o = PI * (o / 180.0);
  uint64 l = pdb.size();
  auto* pdbv = pdb.data();
  #pragma omp parallel for schedule(dynamic)
  for (uint64 i = 0; i < l; i++){
    auto& atom_i = pdbv[i];
    auto* C_I = atom_i.COORDS.data();
    for (uint64 j : atom_i.DD_INTERACTING){
      auto* C_J = pdbv[j].COORDS.data();
      for (uint64 k : atom_i.DD_INTERACTING){
        if (k == j)continue;
        auto* C_K = pdbv[k].COORDS.data();
        float Vik[] = {C_I[0] - C_K[0],
                        C_I[1] - C_K[1],
                        C_I[2] - C_K[2]};
        float Vjk[] = {C_J[0] - C_K[0],
                        C_J[1] - C_K[1],
                        C_J[2] - C_K[2]};
        float mVik =   sqrt(Vik[0]*Vik[0] + Vik[1]*Vik[1] + Vik[2]*Vik[2]);
        float mVjk =   sqrt(Vjk[0]*Vjk[0] + Vjk[1]*Vjk[1] + Vjk[2]*Vjk[2]);
        float nVik[] = { Vik[0]/mVik, Vik[1]/mVik, Vik[2]/mVik };
        float nVjk[] = { Vjk[0]/mVjk, Vjk[1]/mVjk, Vjk[2]/mVjk };
        float dot =    nVik[0]*nVjk[0] + nVik[1]*nVjk[1] + nVik[2]*nVjk[2];
        float angle =  acos(dot);
        if (angle > o){
          Imtrx[i + j * l] = false;
          break;
        }
      }
    }
  }
}void
NE_RemoveNonEffective(vector<atom_struct>&, //pdb
                   float               ,//angle in degrees
                   vector<char>&        );//interaction matrix#include "stdafx.h"
#include "atom_struct.h"
#include "SearchFunctions.h"
#include "PDBparser2.h"

string
GetBasename(string path){
  string result;
  stringstream strstream(path);
  string segment;
  vector<string> seglist;
#ifdef _WIN32
  while(std::getline(strstream, segment, '\\')){
#else
  while(std::getline(strstream, segment, '/')){
#endif
    seglist.push_back(segment);
  }
  result = seglist.back();
  return result;
}

map<string, map<string, int> > ANOLEA = {
    { "GLY", { { "N", 3 },
               { "CA", 2 },
               { "C", 4 },
               { "O", 5 },
               { "OXT", 28 } } },

    { "ALA", { { "N",  3 },
               { "CA", 1 },
               { "C", 4  },
               { "O", 5 },
               { "CB", 6 },
               { "OXT", 28 } } },

    { "VAL", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 7 },
               { "CG1", 6 },
               { "CG2", 6 },
               { "OXT", 28 } } },

    { "LEU", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 7 },
               { "CD1", 6 },
               { "CD2", 6 },
               { "OXT", 28 } } },

    { "ILE", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 7 },
               { "CG1", 8 },
               { "CG2", 6 },
               { "CD1", 6 },
               { "OXT", 28 } } },
    { "MET", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 29 },
               { "SD", 9 },
               { "CE", 30 },
               { "OXT", 28 } } },
   { "MSE", { { "N", 3 },
              { "CA", 1 },
              { "C", 4 },
              { "O", 5 },
              { "CB", 8 },
              { "CG", 29 },
              { "SE", 9 },
              { "CE", 30 },
              { "OXT", 28 } } },

    { "PRO", { { "N", 10 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 8 },
               { "CD", 32 },
               { "OXT", 28 } } },

    { "TRP", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 13 },
               { "CD1", 24 },
               { "CD2", 11 },
               { "NE1", 39 },
               { "CE2", 14 },
               { "CE3", 12 },
               { "CZ2", 12 },
               { "CZ3", 12 },
               { "CH2", 12 },
               { "OXT", 28 } } },

    { "SER", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 15 },
               { "OG", 16 },
               { "OXT", 28 } } },

    { "THR", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 17 },
               { "OG1", 16 },
               { "CG2", 6 },
               { "OXT", 28 } } },

    { "PHE", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 11 },
               { "CD1", 12 },
               { "CD2", 12 },
               { "CE1", 12 },
               { "CE2", 12 },
               { "CZ", 12 },
               { "OXT", 28 } } },

    { "ARG", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 8 },
               { "CD", 37 },
               { "NE", 36 },
               { "CZ", 21 },
               { "NH1", 22 },
               { "NH2", 22 },
               { "OXT", 28 } } },

    { "ASN", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 33 },
               { "OD1", 34 },
               { "ND2", 18 },
               { "OXT", 28 } } },

    { "ASP", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 27 },
               { "OD1", 28 },
               { "OD2", 28 },
               { "OXT", 28 } } },

    { "CYS", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 29 },
               { "SG", 19 },
               { "OXT", 28 } } },

    { "GLN", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 8 },
               { "CD", 33 },
               { "OE1", 34 },
               { "NE2", 18 },
               { "OXT", 28 } } },

    { "GLU", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 8 },
               { "CD", 27 },
               { "OE1", 28 },
               { "OE2", 28 },
               { "OXT", 28 } } },

    { "HIS", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 23 },
               { "ND1", 38 },
               { "CD2", 24 },
               { "CE1", 26 },
               { "NE2", 25 },
               { "OXT", 28 } } },

    { "LYS", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 8 },
               { "CD", 8 },
               { "CE", 35 },
               { "NZ", 20 },
               { "OXT", 28 } } },

    { "TYR", { { "N", 3 },
               { "CA", 1 },
               { "C", 4 },
               { "O", 5 },
               { "CB", 8 },
               { "CG", 11 },
               { "CD1", 12 },
               { "CD2", 12 },
               { "CE1", 12 },
               { "CE2", 12 },
               { "CZ", 31 },
               { "OH", 40 },
               { "OXT", 28 } } },


    //Modified Capriotti etal 2010 U -> DT
    { "DA", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 }, 
              { "C5'", 4 }, { "C4'", 5 },
              { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 }, { "C2'", 5 }, { "C1'", 7 }, 
              { "N9", 9 }, { "C8", 10 },
              { "N7", 11 }, { "C5", 12 }, { "C6", 15 }, { "N6", 16 }, { "N1", 11 }, 
              { "C2", 14 }, { "N3", 11 }, { "C4", 13 } } },

    { "DT", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 }, 
              { "C5'", 4 }, { "C4'", 5 },
              { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 }, { "C2'", 5 }, { "C1'", 7 }, 
              { "N1", 9 }, { "C2", 20 },
              { "O2", 19 }, { "N3", 23 }, { "C4", 18 }, { "O4", 19 }, { "C5", 24 }, 
              { "C7", 25 }, { "C6", 22 },{"C5M",25} } }, //types 24 and 25 added

    { "DC", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 }, 
              { "C5'", 4 }, { "C4'", 5 },
              { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 }, { "C2'", 5 }, { "C1'", 7 }, 
              { "N1", 9 }, { "C2", 20 },
              { "O2", 19 }, { "N3", 11 }, { "C4", 15 }, { "N4", 16 }, { "C5", 21 }, 
              { "C6", 22 } } },

    { "DG", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 }, 
              { "C5'", 4 }, { "C4'", 5 },
              { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 }, { "C2'", 5 }, { "C1'", 7 }, 
              { "N9", 9 }, { "C8", 10 },
              { "N7", 11 }, { "C5", 12 }, { "C6", 18 }, { "O6", 19 }, { "N1", 23 }, 
              { "C2", 17 }, { "N2", 16 },
              { "N3", 11 }, { "C4", 13 } } },
    { "A", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 },
             { "C5'", 4 }, { "C4'", 5 }, { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 },
             { "O2'", 6 }, { "C2'", 5 }, { "C1'", 7 }, { "N9", 9 }, { "C8", 10 },
             { "N7", 11 }, { "C5", 12 }, { "C6", 15 }, { "N6", 16 }, { "N1", 11 },
             { "C2", 14 }, { "N3", 11 }, { "C4", 13 } } },

    { "U", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 },
             { "C5'", 4 }, { "C4'", 5 }, { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 },
             { "O2'", 6 }, { "C2'", 5 }, { "C1'", 7 }, { "N1", 9 }, { "C2", 20 },
             { "O2", 19 }, { "N3", 23 }, { "C4", 18 }, { "O4", 19 }, { "C5", 21 },
             { "C6", 22 } } },

    { "C", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 },
             { "C5'", 4 }, { "C4'", 5 }, { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 },
             { "O2'", 6 }, { "C2'", 5 }, { "C1'", 7 }, { "N1", 9 }, { "C2", 20 },
             { "O2", 19 }, { "N3", 11 }, { "C4", 15 }, { "N4", 16 }, { "C5", 21 },
             { "C6", 22 } } },

    { "G", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 },
             { "C5'", 4 }, { "C4'", 5 }, { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 },
             { "O2'", 6 }, { "C2'", 5 }, { "C1'", 7 }, { "N9", 9 }, { "C8", 10 },
             { "N7", 11 }, { "C5", 12 }, { "C6", 18 }, { "O6", 19 }, { "N1", 23 },
             { "C2", 17 }, { "N2", 16 }, { "N3", 11 }, { "C4", 13 } } },
    { "T", { { "P", 2 }, { "OP1", 1 }, { "OP2", 1 }, { "OP3", 1 }, { "O5'", 3 }, 
             { "C5'", 4 }, { "C4'", 5 },
             { "O4'", 8 }, { "C3'", 5 }, { "O3'", 3 },{"O2'",6}, { "C2'", 5 }, 
             { "C1'", 7 }, { "N1", 9 }, { "C2", 20 },
             { "O2", 19 }, { "N3", 23 }, { "C4", 18 }, { "O4", 19 }, { "C5", 24 }, 
             { "C7", 25 }, { "C6", 22 },{"C5M",25} } },
{"PTS", {{"C03",0},  {"C04",0},  {"C05",0}, {"C08",0}, {"C09",0},  {"C10",0}, {"C11",0}, {"C12",0}, {"C13",0}, {"C14",0}, {"C15",0}, {"C17",0}, {"C18",0}, {"C19",0}, {"O02",0}, {"O06",0},{"O16",0} }}
  };


vector<vector<string> > //ordered strings for each category in the atom tags
ReadPDB_ATOM(string fname){ //filename
  vector<vector<string>> result;
  uint32 cols[15][2] = {{0,6},{6,5},{12,4},{16,1},{17,3},{21,1},{22,4},
                        {26,1},{30,8},{38,8},{46,8},{54,6},{60,6},{76,2},{78,2}};

  //   0  1    2      3    4     5    6     7 8 9 10     11    12   13     14
  //ATOM ID NAME ALTLOC RESN CHAIN RESI ICODE X Y  Z  OCCUP TFACT ELEM CHARGE

  ifstream pdb(fname);

  auto Trim = [](string& str){str.erase(std::remove_if(str.begin(),
                                                       str.end(),
                                                       ::isspace),
                                                       str.end());
  };
  while(pdb.good()){
    string line;
    vector<string> cline;
    getline(pdb,line);
    uint32 tag;
    string atomtag;
    bool notATOM = false;
    try{
      for (tag = 0; tag < 15; ++tag){
        string temp(line,cols[tag][0],cols[tag][1]);
        Trim(temp);
        replace(temp.begin(),temp.end(),'*','\'');
        
        if( tag == 0){ 
          if(temp != "ATOM" && temp != "HETATM"){
            notATOM = true;
            break;
          }
        }
        //cerr << "|"<< temp << "\t";
        cline.push_back(temp);
      }
    }
    catch(exception e){
      if (tag < 10){
        cerr << "Line \"" << tag << "\" has insufficient data.\n";
        continue;
      }
    }
    if(notATOM) continue;
    result.push_back(cline);
    //cout << result.back()[1] << "\n";
  }
  if(result.size() == 0) {
    cerr <<fname << " NO_VALID_ATOMS_IN_PDB\n";
    throw -1;
  }
  return result;
}

void
RemoveAltLocs(vector<atom_struct>& pdb){
/*
Steps:
1- Search for resi/chain pairs with altloc atoms
2- Search how many sets are available
3- Select set with highest occupancy/lowest letter
4- If there is pairs, select highest occupancy or if occupancy is equal select lowest position
*/
  vector<atom_struct> new_pdb;
  //chain,resi+icode to altloc set map for normal altloc in same chain
  map<string,map<pair<int,string>, set<string>>> chain_resi_set;
  bool Normal = false;
  vector<int> removed_pos;
  for (auto atom : pdb){
    if(atom.ALTLOC.empty()) continue;
    auto resi = make_pair(atom.RESI,atom.iCODE);
    chain_resi_set[atom.CHAIN][resi].insert(atom.ALTLOC);
  }
  for (auto ch_resi : chain_resi_set){
    string CHAIN = ch_resi.first;
    auto resi_map = ch_resi.second;
    for(auto resi_set : resi_map){
      int RESI = get<0>(resi_set.first);
      string iCODE = get<1>(resi_set.first);
      //variables to find out best altloc
      //altocs
      vector<string> alt_set(resi_set.second.begin(),resi_set.second.end());
      //do not step into per chain altlocs
      if (alt_set.size() < 2){
        Normal = true;
        continue;
      }
      //positions in the pdb of each altloc set
      vector<vector<uint32>> alt_set_atom_pos(alt_set.size());
      //avg occupancy of each altloc set
      vector<float> avg_oc(alt_set.size());

      for (uint32 i = 0; i < alt_set.size(); ++i){
        string altloc = alt_set[i];
        float oc_count = 0.0;
        float oc_sum = 0.0;
        for(uint32 j = 0; j < pdb.size(); ++j){
          if(pdb[j].CHAIN  != CHAIN  ||
             pdb[j].ALTLOC != altloc ||
             pdb[j].RESI   != RESI   ||
             pdb[j].iCODE  != iCODE) continue;
          oc_count += 1.0;
          oc_sum += pdb[j].OCCUPANCY;
          alt_set_atom_pos[i].push_back(j);
        }
        avg_oc[i] = oc_sum / oc_count;
      }
      float cur_avg_oc = avg_oc[0];
      string cur_altloc = alt_set[0];
      int cur_set = 0;
      for (uint32 i = 1; i < alt_set.size(); ++i){
        if((avg_oc[i] > cur_avg_oc)         ||
           (avg_oc[i] == cur_avg_oc &&
            alt_set[i].compare(cur_altloc) < 0 )){
          removed_pos.insert(removed_pos.end(),
                             alt_set_atom_pos[cur_set].begin(),
                             alt_set_atom_pos[cur_set].end());
          cur_set = i;
          cur_avg_oc = avg_oc[i];
          cur_altloc = alt_set[i];
        }
        else{
          removed_pos.insert(removed_pos.end(),
                             alt_set_atom_pos[i].begin(),
                             alt_set_atom_pos[i].end());
        }
      }
    }
  }
  for (uint32 i = 0; i < pdb.size(); ++i){
//    auto& atom = pdb[i];
    if(removed_pos.end() != find(removed_pos.begin(),removed_pos.end(),i)) {
//       cerr << "NORMAL_ALT_RM\t" << atom.STRUCTURE << "\t" << atom.ID <<"\t"
//            << atom.NAME << "\t"  << atom.RESN << "\t" << atom.RESI << "\t" 
//            << atom.CHAIN << atom.iCODE << "\n";
      continue;
    }
    new_pdb.push_back(pdb[i]);
  }

  pdb = new_pdb;
  if (Normal){
    for (auto ch_resi : chain_resi_set){
      string CHAIN = ch_resi.first;
      auto resi_map = ch_resi.second;
        for(auto resi_set : resi_map){
          //int RESI = get<0>(resi_set.first);
          string iCODE = get<1>(resi_set.first);
          vector<string> alt_set(resi_set.second.begin(),resi_set.second.end());
//           if(alt_set.size() == 1){
//             cerr << "NON_STD_ALT_CHAIN\t" << pdb[0].STRUCTURE << "\t" <<  alt_set[0] << "\n";
//           }
        }
    }


    //starting chain altlocs

  }
  if(new_pdb.size() == 0) throw -1;
}

bool
IsRESNSolvent(string resn){
  const vector<string> solv = {"SO4", "HOH", "EDO", "SF4", "GOL", "EOH", "DOD",  
                               "CPT", "A71", "EHN", "PTN", "O", "MOE", "ACE", "TEA", 
                               "EDO", "CAC", "PEO", "PG4", "SPK", "DRI", "DAG", "TMR",  
                               "NBU", "TRS","RKT", "NAG"};
  return (find(solv.begin(),solv.end(),resn ) != solv.end());
}

bool
IsRESNIon(string resn){
  const vector<string> ions = {"NA","MG","K", "MN","ZN","BA","CO","3CO","AG","NCO","2HP","ACT",
                               "CS","CU","NI","PT","RB","SR","TL","BR","NRU","NH4","CA","CL"};
  return (find(ions.begin(),ions.end(),resn ) != ions.end());
}

void
GetAtomType(string typefname,  //type dictionary
            vector<atom_struct>&            pdb,            //vector of atoms
            bool                            KeepUnknown){
  map<string, map<string, int> > typemap;
  if (typefname.empty()){
    typemap = ANOLEA;
  }
  else{
    typemap = GetTypeMap(typefname);
  }  
  string c_chain = "NULL";
  vector<atom_struct> new_pdb;
  
  for (auto& atom : pdb){
    auto name = atom.NAME;
    auto resn = atom.RESN;
    auto chain = atom.CHAIN;
    //cout << atom.NAME << " " << atom.RESN << "\n"; 
    if(IsRESNSolvent(atom.RESN)){ 
       if(atom.RESN == atom.NAME){
       cerr << "SOLVENT\t" << atom.STRUCTURE << "\t" << atom.ID <<"\t"
            << atom.NAME << "\t"  << atom.RESN << "\t" << atom.RESI << "\t" 
            << atom.CHAIN << atom.iCODE << "\n";
       
      continue;
      }
      if(atom.RESN =="HOH" && atom.NAME == "O"){
    cerr << "SOLVENT\t" << atom.STRUCTURE << "\t" << atom.ID <<"\t"
            << atom.NAME << "\t"  << atom.RESN << "\t" << atom.RESI << "\t" 
            << atom.CHAIN << atom.iCODE << "\n";
       
      continue;


       }
    }
    if( IsRESNIon(atom.RESN) && (atom.NAME == atom.RESN)){ 
       cerr << "ION\t" << atom.STRUCTURE << "\t" << atom.ID <<"\t"
            << atom.NAME << "\t"  << atom.RESN << "\t" << atom.RESI << "\t" 
            << atom.CHAIN << atom.iCODE << "\n";
      continue;
    }
    if(!typemap.count(resn)) resn = FixRESN(resn);
    if(typemap.count(resn) && typemap.at(resn).count(name)){
      int type = typemap.at(resn).at(name);
      //entering new chain
      if(c_chain != chain && atom.MOL_TYPE == "PROTEIN"){
        c_chain = chain;
        if(type == 3 || type == 10){
          type = 20;
        }
      }
      if(c_chain != chain && atom.MOL_TYPE == "RNA" ){
        c_chain = chain;
        if(type == 3 && atom.NAME == "O3'"){
          type = 6;
        }
      }
      atom.ATOM_TYPE = type;
      new_pdb.push_back(atom);
    }
    else{
      if(KeepUnknown && (atom.ELEMENT != "H")) {
        new_pdb.push_back(atom);
      
        /*cerr << "UNKNOWN_TYPE_POT\t"<< atom.STRUCTURE << "\t" << atom.ID <<"\t"
              << atom.NAME << "\t" << atom.RESN << "\t" << atom.RESI << "\t" 
              << atom.CHAIN << atom.iCODE << "\n";*/
      }
    } 
  }

  auto orgpdb = OrganizePDB(new_pdb);
  for (auto& chain : orgpdb){
    auto& last_res = chain.back();
    for (auto& atom_p : last_res){
      if (atom_p->MOL_TYPE == "RNA" &&
          atom_p->ATOM_TYPE == 3 &&
          atom_p->NAME == "O3'") atom_p->ATOM_TYPE = 6;
    }
  }

  if(new_pdb.size() == 0)  {
    cerr << "NO_VALID_ATOMS_TYPE\n";
    throw -1;
  }
  pdb = new_pdb;
}

string
FixRESN(string resn){
  extern map<string,string> nucresn;
  try{
    return nucresn.at(resn);
  }
  catch(exception e){
    //cerr << "UNKNOWN_NON_STANDARD_RESN " << resn << "\n";
    return resn;
  }
  return resn;
}

string
FixNAME(string name){
  if(name == "O1P")
    return "OP1";
  if(name == "O2P")
    return "OP2";
  if(name == "O3P")
    return "OP3";
  if(name == "O4P")
    return "OP4";
  return name;
}



void
GetMolType(vector<atom_struct>& pdb){
  vector<string> amino_acids = {
                "ALA", "ARG", "ASN", "ASP", "CYS", "GLN", "GLU",
                "GLY", "HIS", "ILE", "LEU", "LYS", "MET", "PHE", 
                "PRO", "SER", "THR", "TRP", "TYR", "VAL"
             };
  vector<string> nucs = {"A","T","G","C","U","DA","DT","DG","DC"};
  auto orgpdb = OrganizePDB(pdb);
  for (auto& chain : orgpdb){
    for (auto& res : chain){
      string type = "";
      bool nuc = false;
      bool o2p = false;
      for (auto& atom_p : res){
        if (atom_p->HETATM) continue;
        //if(atom_p->NAME == "CA" || atom_p->NAME == "C" || atom_p->NAME =="N" || atom_p->NAME == "O" || atom_p->NAME=="OXT"){ 
          //type = "PROTEIN";
        if(find(amino_acids.begin(),amino_acids.end(),atom_p->RESN) != amino_acids.end()){
          type = "PROTEIN";
          //else type ="";
          break;
        }
        if(atom_p->NAME == "P" || atom_p->NAME == "O5'" || atom_p->NAME == "C5'"){ 
          if(find(nucs.begin(),nucs.end(),atom_p->RESN) != nucs.end()) nuc = true;
        }
        if(atom_p->NAME == "O2'" && nuc){
          type = "RNA";
          o2p = true;
          break;
        }
      }
      if(nuc && !o2p) type = "DNA";
      else if (type.empty()) type = "LIGAND";
      //cout << "___" << std::endl;
      for (auto& atom_p : res){
        //if (type == "LIGAND") cout << atom_p->print() << std::endl;
        if (!atom_p->HETATM) atom_p->MOL_TYPE = type;
        else atom_p->MOL_TYPE="LIGAND";
      }
    }
  }
}

map<string, map<string, int> >
GetTypeMap(string filename){

  map<string, map<string, int> > result;
  ifstream potfile(filename, ifstream::in);
  while (potfile.good()){
    string line;
    getline(potfile, line);
    if (line.size() >= 1){
      if (string(line, 0, 1) == string("#"))
        continue;
      istringstream buffer(line);
      vector<string> tokens((istream_iterator<string>(buffer)), istream_iterator<string>());
      if (tokens.size() == 5){

        /*for (auto str : tokens){
        cerr << str << "\t";
        }*/
        auto& atoms = result[tokens[1]];
        atoms[tokens[2]] = stoi(tokens[4]);
        //cerr << "\n";
      }
    }
  }
  return result;
}


vector<atom_struct> //final structure
PDBparser(string pdbfname, //pdb filename or mol2
          string typefname, //type filename
          bool KeepUnknown){
  if(pdbfname.find(".mol2") != std::string::npos){
    return MOL2parser(pdbfname,typefname,KeepUnknown);
  }

  string basename = GetBasename(pdbfname);
  vector<atom_struct> result;


  auto lines = ReadPDB_ATOM(pdbfname);
  //cout << lines.size() << "\n";
  for (auto line : lines){
    int ID = 0;
    string name;
    string altloc;
    string resn;
    string chain;
    int resi = 0;
    string icode = " ";
    float X = 0;
    float Y = 0;
    float Z = 0;
    float oc = 0;
    float tf = 0;
    string ele = "";
    string chg = "";
    bool hetatm = line[0] == "HETATM";
    for (uint32 i = 1; i < line.size(); ++i){
      switch (i){
        case 1: //ID
          try{
            ID = stoi(line[i]);
          }
          catch(exception e){
            cerr << "ID error\n";
          }
          break;
        case 2: //NAME
          name = FixNAME(line[i]);
          break;
        case 3: //ALTLOC
          altloc = line[i];
          break;
        case 4: //RESN
          resn = line[i];
          break;
        case 5: //CHAIN
          if(line[i].empty()) chain = "_";
          else                chain = line[i];
          break;
        case 6: //RESI
          try{
            resi = stoi(line[i]);
          }
          catch(exception e){
            cerr << "RESI error\n";
          }
          break;
        case 7: //ICODE
          icode = line[i];
          break;
        case 8:  //X
          try{
            replace(line[i].begin(),line[i].end(),',','.');
            X = stod(line[i]);
          }
          catch(exception e){
            cerr << "X error\n";
          }
          break;
        case 9:  //Y
          try{
            replace(line[i].begin(),line[i].end(),',','.');
            Y = stod(line[i]);
          }
          catch(exception e){
            cerr << "Y error\n";
          }
          break;
        case 10: //Z
          try{
            replace(line[i].begin(),line[i].end(),',','.');
            Z = stod(line[i]);
          }
          catch(exception e){
            cerr << "Z error\n";
          }
          break;
        case 11: //OCCUP
          try{
            replace(line[i].begin(),line[i].end(),',','.');
            oc = stod(line[i]);
          }
          catch(exception e){
            cerr << "OC error\n";
          }
          break;
        case 12: //TFACT
          try{
            replace(line[i].begin(),line[i].end(),',','.');
            tf = stod(line[i]);
          }
          catch(exception e){
            cerr << "TF error\n";
          }
          break;
        case 13: //ELEM
          ele = line[i];
          break;
        case 14: //CHARGE
          chg = line[i];
          break;
      }
    }
    atom_struct current_atom(ID,
                             resi,
                             icode,
                             name,
                             resn,
                             chain,
                             ele,
                             basename,
                             "",
                             X,
                             Y,
                             Z,
                             altloc,
                             oc,
                             tf,
                             chg);
    current_atom.HETATM = hetatm;
    result.push_back(current_atom);
//     cout << line[1] << "\n";
//     cout << current_atom.print() << "\n";
  }

  RemoveAltLocs(result);
  GetMolType(result);
  GetAtomType(typefname,result,KeepUnknown);
  FixRepeatID(result);
//   for(auto atom : result){
//     cerr << "|"<<atom.print() << "|"<< "\n";
//   }
  if(result.size() == 0)  {
    cerr << "NO_VALID_ATOMS_FINAL\t" << pdbfname;
    throw -1;
  }
  //for (auto& atom : result) atom.DD_DISTANCES.resize(result.size());
  return result;
}

void
ChainSelector(vector<vector<string>>& selection,
              vector<atom_struct>& pdb){
  vector<uint32> removed_pos;
  vector<atom_struct> new_pdb;
  for (uint32 i = 0; i < pdb.size(); ++i){
    bool selected = false;
    for(auto obj : selection){
      for(auto chain : obj){
        if(chain == pdb[i].CHAIN){
          selected = true;
          break;
        }
      }
    }
    if(!selected) removed_pos.push_back(i);
  }
  for (uint32 i = 0; i < pdb.size(); ++i){
    if(removed_pos.end() != find(removed_pos.begin(),removed_pos.end(),i)) {
      //cerr << pdb[i].print() << " *\n";
      continue;
    }
    //cerr << pdb[i].print() << "\n";
    new_pdb.push_back(pdb[i]);
  }
  if(new_pdb.size() == 0) {
    cerr << "NO_VALID_ATOMS_IN_SELECTION\t";
    throw -1;
  }
  pdb = new_pdb;
}

void
FixRepeatID(vector<atom_struct>& pdb){
  map<uint32,uint32> counter;
  for (auto& atom : pdb){
    counter[atom.ID]++;
  }
  bool repeatID = false;
  for (auto it : counter){
    if (it.second != 1){
      repeatID = true;
      break;
    }
  }
  if(repeatID){
    for (uint32 i = 0; i < pdb.size(); ++i){
      pdb[i].ID = i+1; 
    }
  }
}

vector<atom_struct>
MOL2parser(string fname,
          string typefname,
          bool KeepUnknown){
  vector<atom_struct> result;
 

  ifstream mol2(fname);
  auto Trim = [](string& str){str.erase(std::remove_if(str.begin(),
                                                       str.end(),
                                                       ::isspace),
                                                       str.end());};

 
  string lastsection = "";
  map<string,vector<string>> sections;
  uint CHAINn = 0;
  while(mol2.good()){ 
    string line;
    vector<string> cline;
    getline(mol2,line);
    std::replace(line.begin(),line.end(),'\t',' ');
    line.erase( std::remove(line.begin(),line.end(), '\r'), line.end() );

    if (std::string::npos != line.find("@<TRIPOS>MOLECULE")){
      //new molecule found
      if(sections.size() != 0){ 
        vector<atom_struct> temp;
        MOL2_parse_map(sections,
                     temp,
                     CHAINn);
        result.insert(result.end(),temp.begin(),temp.end());
        sections.clear();
        lastsection = "";
      }
    }

    if (std::string::npos != line.find("@<TRIPOS>")) {
      lastsection = line;
      sections[line] = vector<string>();
      continue;
    }
    
    if (lastsection == "") continue;
    else{
      sections[lastsection].push_back(line);
    }      
  }

  vector<atom_struct> temp;
  
  MOL2_parse_map(sections,
                 temp,
                 CHAINn);
  
  result.insert(result.end(),temp.begin(),temp.end());
  GetMolType(result);
  GetAtomType(typefname,result,KeepUnknown);
  map<int,string> resi2chain;
  for(auto& atom : result){ 
    atom.STRUCTURE = GetBasename(fname);
    if(atom.CHAIN != "_")
    resi2chain[atom.RESI] = atom.CHAIN;
  }
  for(auto& atom : result){
    if(atom.CHAIN == "_") atom.CHAIN = resi2chain.at(atom.RESI);
  }
  return result;
}



void 
MOL2_parse_map(map<string,vector<string>>& sections,
               vector<atom_struct>& result,
               uint& CHAINn){


  auto Split = [](string const &input) { 
    std::istringstream buffer(input);
    vector<string> ret((std::istream_iterator<string>(buffer)),
                        std::istream_iterator<string>());
    return ret;};
 
  map<string,string> sybyl2ele = {{"C.3","C"},{"C.2","C"}, {"C.ar","C"}, {"C.2","C"}, {"C.1","C"}, {"C.cat","C"}, 
                                  {"N.4","N"}, {"N.3","N"}, {"N.2","N"}, {"N.pl3","N"}, {"N.1","N"},{"N.am","N"},{"N.ar","N"},
                                  {"O.3","O"}, {"O.2","O"},{"O.co2","O"},
                                  {"S.3","S"},{"S.2","S"}, {"S.O2","S"},{"S.O","S"}, {"S.o2","S"},{"S.o","S"}, 
	                          {"H","H"},    
                                  {"P.3","P"},
                                  {"CL","CL"},{"Cl","CL"},
                                  {"F","F"}};
  map<int,int> ID2pos;
  set<int> valid_ID;
 
  //get atoms
  if (!sections.count("@<TRIPOS>ATOM")){
    cerr << "NO_VALID_ATOMS_MOL2\n";
    return;
  }


  for (string& line : sections["@<TRIPOS>ATOM"]){
    vector<string> tokens = Split(line);
    if(tokens.size() < 6) continue;
    int ID = stoi(tokens[0]);
    string name = FixNAME(tokens[1]);
    float X = stof(tokens[2]);
    float Y = stof(tokens[3]);
    float Z = stof(tokens[4]);
    string type = tokens[5];
    if (type.size() > 5) type = type.substr(0,5);    
    if (type == "H") continue;
    valid_ID.insert(ID);
    string altloc = "";
    string resn = "";
    string chain = "_";
    int resi = 0;
    string icode = "";
    //cout << line << "\n";
    if(tokens.size() >= 6 || line.size() >= 56){ 
/*      try{
        int resi_ = stoi(line.substr(52,4));
        resi = resi_;
      }catch(exception e){}*/
      if (resi == 0){
       resi = stoi(tokens[6]);
      }
     
      if(tokens.size() > 7 || line.size() >= 69){
        string resn_;
/*        if(line.size() >= 69){ 
          try{
            resn_= line.substr(58,9);
          }
          catch(exception e){
            resn_ = tokens[7];
          }
        }
        else*/ resn_ = tokens[7];
        resn_.erase(resn_.find_last_not_of(" \n\r\t")+1);
        resn_ = resn_.substr(0,3);
        for(char c : resn_){
          if (!isdigit(c)){
            if (c == '-') break;
            resn += c;
          }
          else break;
        }
      }
      else resn = "___";
    }   
    float oc = 0;
    float tf = 0;
    string ele = "";
    if(sybyl2ele.find(type) != sybyl2ele.end()) ele = sybyl2ele[type];
    else ele = name.substr(0,2);
    atom_struct current_atom(ID,
                             resi,
                             icode,
                             name,
                             resn,
                             chain,
                             ele,
                             "",
                             "",
                             X,
                             Y,
                             Z,
                             altloc,
                             oc,
                             tf,
                             type);
    current_atom.DTYPE = "MOL2";
    current_atom.HETATM = false;
    ID2pos[ID] = result.size();
     
    result.push_back(current_atom);
  
  }
  if (!sections.count("@<TRIPOS>BOND")){
    cerr << "No bond section, falling back to chain identification by molecule type. (unimplemented)\n";
  }
  else{
    vector<vector<int>> bonded_sets;
    vector<vector<std::pair<int,int>>> plist;
    for(string& line : sections["@<TRIPOS>BOND"]){
      vector<string> tokens = Split(line);
      if (tokens.size() < 3) continue;
      int oID = stoi(tokens[1]);
      int tID = stoi(tokens[2]);
      if(!valid_ID.count(oID) || !valid_ID.count(tID)) continue;
      int RoID = ID2pos[oID];
      int RtID = ID2pos[tID];
      vector<std::pair<int,int>> uset;
      uset.push_back(std::make_pair(RoID,RtID));
      plist.push_back(uset);
    }
    bool notdone = true;
    while(notdone){
      notdone = false;
      for(uint i = 0; i < plist.size(); ++i){
        auto& set_list = plist[i];
        for(uint j = 0; j < set_list.size(); ++j){
          int set[2] = {set_list[j].first,set_list[j].second};
          for(int& p : set){
            for(uint k = 0; k < plist.size(); ++k){
              if(k == i) continue;
              auto& o_set_list = plist[k];
              for(uint l = 0; l < o_set_list.size();++l){
                int o_set[2] = {o_set_list[l].first,o_set_list[l].second};
                for(int& o_p : o_set){
                  if(p == o_p){
                    set_list.push_back(o_set_list[l]);
                    o_set_list.pop_back();
                    notdone = true;
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }

    
    for (uint i = 0; i < plist.size(); ++i){
      set<int> uID;
      auto& set_list = plist[i];
      for (int j = 0; j < set_list.size(); ++j){
        auto& pair = set_list[j];
        uID.insert(pair.first);
        uID.insert(pair.second);
      }
      if(uID.empty()) continue;
      vector<int> tmp;
      for(const int& id : uID) tmp.push_back(id);
      bonded_sets.push_back(tmp);
    }
    const char* alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_________________________";
    
    for(int i = 0; i < bonded_sets.size() && i < 40 ; ++i) {
      for (int& id : bonded_sets[i]){
        result[id].CHAIN=alphabet[i+CHAINn];
      }
    }
    CHAINn += bonded_sets.size();
   
  }
}
string
GetBasename(string);

vector<vector<string> > //ordered strings for each category in the atom tags
ReadPDB_ATOM(string); //filename

void
RemoveAltLocs(vector<atom_struct>&); //removes altlocs from intermediary list

void
GetMolType(vector<atom_struct>&);

void
GetAtomType(string,  //type dictionary fname
            vector<atom_struct>&,            //vector of atoms
            bool);                          //keep unknown type atoms

vector<atom_struct> //final structure
PDBparser(string, //pdb filename
          string, //type filename
          bool);  //keep unknown type atoms
//read type map from text file
map<string, map<string, int> >
GetTypeMap(string);

void
ChainSelector(vector<vector<string>>&,
              vector<atom_struct>&);
string
FixRESN(string);

string
FixNAME(string);

void 
FixRepeatID(vector<atom_struct>&);

bool
IsRESNSolvent(string);

bool
IsRESNIon(string);

int
InputType(string);

vector<atom_struct>
MOL2parser(string,string,bool); //mol2 filename

void 
MOL2_parse_map(map<string,vector<string>>& sections,
               vector<atom_struct>& result,
               unsigned int& CHAINn);
#include "stdafx.h"
#include "atom_struct.h"
#include "SearchFunctions.h"
#define MAX_INT pow(2,24)
/*vector<residue_struct>
GetResidues(vector<atom_struct>& pdb){
    map<int,residue_struct> data;
    vector<residue_struct> result;
    for (auto* p = pdb.data(); p != p + pdb.size(); ++p){
        if(data.count(p->RESI) > 0){
            auto& res = data[p->RESI];
            res.RESN = p->RESN;
            res.RESI = p->RESI;
            res.CHAIN = p->CHAIN;
            res.STRUCT_TYPE = p->STRUCT_TYPE
            res.STRUCTURE = p->STRUCTURE;
            res.SASA+=p->SASA;
            res.dSASA+=p->EXT1;
            res.ATOMS.push_back(p);
        }
        else{
            auto& res = data[p->RESI]
            res.SASA+=p->SASA;
            res.dSASA+=p->EXT1;
            res.ATOMS.push_back(p);
        }
    }
    result.reserve(data.size());
    for (auto it = data.begin(); it != data.end(); ++it){
        result.push_back(it->second);
    }
    return result;
}*/

vector<atom_struct*>
GetAtoms(string               resn,
         string               chain,
         int                  resi,
         string               icode,
         vector<atom_struct>& pdb){
  vector<atom_struct*> result;
  auto* p = pdb.data();
  auto* end = p + pdb.size();
  auto searcher = [](string left,string right){
    bool result = right.empty() ? true : left == right;
    return result;
  };
  for (;p != end ; ++p){
    if(searcher(p->RESN,resn) &&
       searcher(p->CHAIN,chain) &&
       ((resi == MAX_INT) ? true : (p->RESI == resi)) && 
       searcher(p->iCODE,icode)){
//      cout << chain << " " << resi << " | " << p->RESN << " " << int(p->CHAIN == chain) << " " << p->RESI << "\n";
      result.push_back(p);
      }
    }
   return result;
}

vector<atom_struct>
ReorderPDB(vector<atom_struct>& pdb){
  auto orgpdb = OrganizePDB(pdb);
  vector<atom_struct> result;
  for(auto& chain : orgpdb)
    for(auto& res : chain)
      for(auto& atom : res){
        result.push_back(*atom);
      }
  return result;
}

vector<vector<vector<atom_struct*>>>
OrganizePDB(vector<atom_struct>& pdb){
  vector<vector<vector<atom_struct*>>> result;
  set<string> CHAINs;
  map<string,set<int>> RESIs;
  for(auto& atom : pdb){
    CHAINs.insert(atom.CHAIN);
    RESIs[atom.CHAIN].insert(atom.RESI);
  }
  vector<string> CHAIN(CHAINs.begin(),CHAINs.end());
  sort(CHAIN.begin(),CHAIN.end());
  for (auto& chain : CHAIN){
    vector<vector<atom_struct*>> cur_chain;
    vector<int> RESI(RESIs[chain].begin(),RESIs[chain].end());
    sort(RESI.begin(),RESI.end());
//    cout <<"___\n";
    for (auto& resi : RESI){
       auto atoms = GetAtoms("",chain,resi,"",pdb);
//       for(auto& atom : atoms){
//         cout << atom->print() << "\n";
//       }
       cur_chain.push_back(atoms);
    }
    result.push_back(cur_chain);
  }
  return result;
}


/*vector<atom_struct*>
GetAtomsFromRESI(int,vector<residue_struct>&){
    vector<atom_struct*> r;
    return r;
}*/

/*vector<residue_struct*>
GetRESN(string,vector<residue_struct>&){
    vector<residue_struct*> r;
    return r;
}*/

map<string,int>
GetTypeFromRESI(string resn,
                string chain,
                int resi,
        string icode,
        vector<atom_struct>& pdb){
  map<string,int> result;
  auto* p = pdb.data();
  auto* end = p + pdb.size();
  for (;p != end ; ++p){
    if(p->RESN == resn &&
           p->CHAIN == chain &&
           p->RESI == resi &&
           p->iCODE == icode) {
      result["ATOM_TYPE"] = p->ATOM_TYPE;
      result["ATOM_TYPE_40"] = p->ATOM_TYPE_40;
      break;
    }
  }

  return result;

}

// vector<string> 
// LineSplitter(string line,
//              char   sep){
//   stringstream   linestream(line);
//   string         data;
//   vector<string> thisline;
//   getline(linestream, data, sep);
//   thisline.push_back(data);
//   while(linestream){
//     string cur;
//     linestream >> cur;
//     thisline.push_back(cur);
//     //cout << cur << "\t";
//   }
//     //cout << "\n";
//   return thisline;
// }

vector<string> 
LineSplitter(string line,
             char   sep){
  stringstream   linestream(line);
  string         data;
  vector<string> thisline;
  while(linestream){
    if(getline(linestream, data, sep))
      thisline.push_back(data);
    //cout << cur << "\t";
  }
    //cout << "\n";
  return thisline;
}

vector<vector<string>>
ReadTabSeparatedFile(string fname){
  //cout << fname << "\n";
  ifstream file(fname);
  string   line;
  vector<vector<string>> result;
  while(getline(file, line))
  {
    vector<string> thisline = LineSplitter(line,'\t');
    result.push_back(thisline);
  }
  return result;
}

vector<vector<string>>
ReadTabSeparatedString(string data){
  //cout << fname << "\n";
  istringstream file(data);
  string   line;
  vector<vector<string>> result;
  while(getline(file, line))
  {
    vector<string> thisline = LineSplitter(line,'\t');
    result.push_back(thisline);
  }
  return result;
}
vector<atom_struct*>
GetAtoms(string,
         string,
         int,
				 string,
				 vector<atom_struct>&);

vector<vector<vector<atom_struct*>>>
OrganizePDB(vector<atom_struct>&);

vector<atom_struct>
ReorderPDB(vector<atom_struct>&);

/*vector<atom_struct*>
GetAtomsFromRESI(int,
				 vector<residue_struct>&);*/

/*vector<residue_struct>
GetRESN(string,
		vector<atom_struct>&);*/

/*vector<residue_struct>
GetRESN(string,
		vector<residue_struct>&);*/

map<string,int>
GetTypeFromRESI(string,
                string,
                int,
								string,
								vector<atom_struct>);

vector<vector<string>>
ReadTabSeparatedFile(string);

vector<vector<string>>
ReadTabSeparatedString(string);


vector<string> 
LineSplitter(string,
             char);
#include "stdafx.h"
#include "atom_struct.h"
#include "SearchFunctions.h"
#include "SetRadius.h"


VDWcontainer::VDWcontainer(string vdwfile){
  vector<vector<string>> fpdb = ReadTabSeparatedString(pdbradii);
  vector<vector<string>> fmol2 = ReadTabSeparatedString(mol2radii);

  load_data(fpdb);
  load_data(fmol2);
  if(vdwfile != ""){
    cerr << "#Loading external VdW radius file.\n";
    try{
      vector<vector<string>> f = ReadTabSeparatedFile(vdwfile);
      load_data(f);
    } 
    catch(exception e){
      cerr << "Invalid VDW file.\n";
    }
  }
}

VDWcontainer::VDWcontainer(){
}

void
VDWcontainer::load_data(vector<vector<string>> f){
  if(f[0][0] == "PDB_RADIUS_FILE"){
    map<string, map<string,float> > newmap;
    map<string, map<string,int> > newmap_pol;
    string cur_res = "";
    for (auto& line : f){

      if (line.size() != 4) continue;
      if (line[0] == "RESIDUE"){
        cur_res = line[2];
        continue; 
      }
      if (line[0] == "ATOM"){
        string name = line[1];
        float vdw = stof(line[2]);
        int   pol = stoi(line[3]);
        if (newmap.count(cur_res) == 0) {
           map<string,float> tmp;
           newmap[cur_res] = tmp;
        }
        if (newmap_pol.count(cur_res) == 0) {
           map<string,int> tmp;
           newmap_pol[cur_res] = tmp;
        }
        newmap[cur_res][name] = vdw;
        newmap_pol[cur_res][name] = pol;
      }
    }
    Map = newmap;
    MapPolarity = newmap_pol;
  }
  else if(f[0][0] == "MOL2_RADIUS_FILE"){
    map<string,float> newmap;
    map<string,int> newmap_pol;
    for (auto& line : f){
      if(line.size() != 4) continue;
      if(line[0] == "SYBYL"){
        newmap[line[1]] = stof(line[2]);
        newmap_pol[line[1]] = stoi(line[3]);
      }
    }        
    u_vdw_radii = newmap;
    u_vdw_radii_polarity = newmap_pol;
  }
  else throw;    
}

string
VDWcontainer::CorrectRESN(string resn){
  extern map<string,string> nucresn;
  try{
    return nucresn.at(resn);
  }
  catch(exception e){
    return resn;
  }
}

void VDWcontainer::SetRadius(vector<atom_struct>& atoms,float probe){

  auto set_unknown = [](atom_struct& a){
      string set_to = "NONE";
    if (a.ELEMENT == "H"){
      a.VDW = 1.0;
      set_to = "H";
      a.POLAR = 0;
      a.ACTIVE=false;
    }
    if (a.ELEMENT == "C"){
      a.VDW = 1.8;
      a.POLAR = 0;
      set_to = "C";
    }
    if (a.ELEMENT == "N"){
      a.VDW = 1.6;
      a.POLAR = 1;
      set_to = "N";
    }
    if (a.ELEMENT == "O"){
      a.VDW = 1.4;
      a.POLAR = 1;
      set_to = "O";
    }
    if (a.ELEMENT == "P"){
      a.VDW = 1.9;
      a.POLAR = 1;
      set_to = "P";
    }
    if (a.ELEMENT == "S"){
      a.VDW = 1.85;
      a.POLAR = 0;
      set_to = "S";
    }
    if (a.ELEMENT == "SE"){
      a.VDW = 1.9;
      a.POLAR = 0;
      set_to = "SE";
    }
    if (a.ELEMENT == "I"){
      a.VDW = 2.094;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
      set_to = "I";
    }
    if (a.ELEMENT == "F"){
      a.VDW = 1.560;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "F";
    }
    if (a.ELEMENT == "Br" || a.ELEMENT == "BR"){
      a.VDW = 1.978;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Br";
    }
    if (a.ELEMENT == "Cl" || a.ELEMENT == "CL"){
      if (a.NAME == a.RESN && (a.RESN == "CL" || a.RESN == "Cl")) a.VDW = 1.81;
      else a.VDW=1.74;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Cl";
    }
    if (a.ELEMENT == "Al" || a.ELEMENT == "AL"){
      a.VDW = 0.54;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Al";
    }
    if (a.ELEMENT == "As" || a.ELEMENT == "AS"){
      a.VDW = 0.58;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "As";
    }
    if (a.ELEMENT == "Au" || a.ELEMENT == "AU"){
      a.VDW = 1.37;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Au";
    }
    if (a.ELEMENT == "Ba" || a.ELEMENT == "BA"){
      a.VDW = 1.35;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Ba";
    }
    if (a.ELEMENT == "Be" || a.ELEMENT == "BE"){
      a.VDW = 0.45;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Be";
    }
    if (a.ELEMENT == "Bi" || a.ELEMENT == "BI"){
      a.VDW = 1.03;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Bi";
    }
    if (a.ELEMENT == "Ca" || a.ELEMENT == "CA"){
      a.VDW = 1.00;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Ca";
    }
    if (a.ELEMENT == "Cd" || a.ELEMENT == "CD"){
      a.VDW = 0.95;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Cd";
    }
    if (a.ELEMENT == "Cr" || a.ELEMENT == "CR"){
      a.VDW = 0.73;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Cr";
    }
    if (a.ELEMENT == "Cs" || a.ELEMENT == "CS"){
      a.VDW = 1.67;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Cs";
    }
    if (a.ELEMENT == "Cu" || a.ELEMENT == "CU"){
      a.VDW = 0.73;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Cu";
    }
    if (a.ELEMENT == "Fe" || a.ELEMENT == "FE"){
      a.VDW = 0.65;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Fe";
    }
    if (a.ELEMENT == "Ga" || a.ELEMENT == "GA"){
      a.VDW = 0.62;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Ga";
    }
    if (a.ELEMENT == "Ge" || a.ELEMENT == "GE"){
      a.VDW = 0.73;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Ge";
    }
    if (a.ELEMENT == "Hg" || a.ELEMENT == "HG"){
      a.VDW = 1.02;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Hg";
    }
    if (a.ELEMENT == "K" || a.ELEMENT == "K"){
      a.VDW = 1.38;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "K";
    }
    if (a.ELEMENT == "Li" || a.ELEMENT == "LI"){
      a.VDW = 0.76;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Li";
    }
    if (a.ELEMENT == "Mg" || a.ELEMENT == "MG"){
      a.VDW = 0.72;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Mg";
    }
    if (a.ELEMENT == "Mn" || a.ELEMENT == "MN"){
      a.VDW = 0.83;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Mn";
    }
    if (a.ELEMENT == "Mo" || a.ELEMENT == "MO"){
      a.VDW = 0.69;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Mo";
    }
    if (a.ELEMENT == "Na" || a.ELEMENT == "NA"){
      a.VDW = 1.02;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Na";
    }
    if (a.ELEMENT == "Ni" || a.ELEMENT == "NI"){
      a.VDW = 0.69;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Ni";
    }
    if (a.ELEMENT == "Pb" || a.ELEMENT == "PB"){
      a.VDW = 1.19;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Pb";
    }
    if (a.ELEMENT == "Pd" || a.ELEMENT == "PD"){
      a.VDW = 0.86;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Pd";
    }
    if (a.ELEMENT == "Rb" || a.ELEMENT == "RB"){
      a.VDW = 1.52;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Rb";
    }
    if (a.ELEMENT == "Sb" || a.ELEMENT == "SB"){
      a.VDW = 0.76;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Sb";
    }
    if (a.ELEMENT == "Sc" || a.ELEMENT == "SC"){
      a.VDW = 0.75;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Sc";
    }
    if (a.ELEMENT == "Sn" || a.ELEMENT == "SN"){
      a.VDW = 0.69;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Sn";
    }
    if (a.ELEMENT == "Sr" || a.ELEMENT == "SR"){
      a.VDW = 1.18;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Sr";
    }
    if (a.ELEMENT == "Tc" || a.ELEMENT == "TC"){
      a.VDW = 0.65;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Tc";
    }
    if (a.ELEMENT == "Ti" || a.ELEMENT == "TI"){
      a.VDW = 0.86;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Ti";
    }
    if (a.ELEMENT == "V"){
      a.VDW = 0.79;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "V";
    }
    if (a.ELEMENT == "Zn" || a.ELEMENT == "ZN"){
      a.VDW = 0.74;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Zn";
    }
    if (a.ELEMENT == "Zr" || a.ELEMENT == "ZR"){
      a.VDW = 0.72;
      if(a.NAME == a.ELEMENT) a.POLAR=1;
      else a.POLAR =0;
set_to = "Zr";
    }

    if (set_to == "NONE"){
      a.VDW = 0;
      a.ACTIVE = false;
    }else{
      a.ACTIVE = true;
    }
  };

  for (uint32 i = 0;i<atoms.size();++i){
    auto& atom = atoms[i];
    if(atom.DTYPE == "MOL2"){
      string ch_name = "";
      float vdw;
      int pol;
      try{
        vdw = u_vdw_radii.at(atom.CHARGE);
        pol = u_vdw_radii_polarity.at(atom.CHARGE); 

        atom.VDW = vdw;
        atom.POLAR = pol;
        atom.ACTIVE = true;
      }
      catch(exception e){
        cerr << "MOL2_UNKNOWN_TYPE";
        set_unknown(atom);
        if (atom.VDW != 0.0) cerr << "_FIXED ";
        else cerr << " ";
        cerr  <<atom.NAME <<"|" <<atom.RESN << "|" <<atom.RESI<< "|" << atom.CHAIN << "|" << atom.CHARGE << "|" << atom.ELEMENT << "|" << atom.VDW << "\n";
 
      }
    }
    else{
      if(Map.count(atom.RESN) > 0){
        auto& names = Map.at(atom.RESN);
        auto& namesP = MapPolarity.at(atom.RESN);
        if(names.count(atom.NAME) > 0){
            atom.VDW = names.at(atom.NAME);
            atom.POLAR = namesP.at(atom.NAME);
        }
        else{
          cerr << "UNKNOWN_VDW_NAME";
          set_unknown(atom);
          if(atom.VDW != 0) cerr << "_FIXED ";
          else cerr << " ";
          cerr <<atom.STRUCTURE << "|" << atom.NAME << "|" << atom.RESN <<
           "|" << atom.RESI << "|" <<atom.CHAIN << atom.iCODE<< "|" << atom.ELEMENT<< "|" << atom.VDW << "\n";
        }
      }
      else {
        string resn = CorrectRESN(atom.RESN);
        if(Map.count(resn) > 0 && Map.at(resn).count(atom.NAME) > 0){
          atom.VDW = Map.at(resn).at(atom.NAME);
        }else {
          cerr << "UNKNOWN_VDW";
          set_unknown(atom);
          if (atom.VDW != 0)cerr << "_FIXED ";
          else cerr << " ";
          cerr <<atom.STRUCTURE << "|" << atom.NAME << "|" << atom.RESN <<
                  "|" << atom.RESI << "|" <<atom.CHAIN << atom.iCODE<< "|" << atom.ELEMENT<< "|" << atom.VDW << "\n";
        }
      }
    }
    if(atom.ACTIVE){
      atom.RADIUS = atom.VDW + probe;
      atom.RADIUS2 = atom.RADIUS * atom.RADIUS;
      atom.AREA = atom.RADIUS2*4.0*PI;
      //cout << atom.ID << "\t" << atom.RADIUS << "\t" << atom.RADIUS2 << "\n";
    }
  }
}

void VDWcontainer::SetShell(vector<atom_struct>& pdb){
  auto* p = Points.data();
  auto p_s3 = Points.size();
  auto p_s = p_s3 / 3;
  auto pdb_s = pdb.size();
  for (uint32 i = 0; i < pdb_s; ++i){
    auto& atom_i = pdb[i];
    if (!atom_i.ACTIVE) continue;
    atom_i.SHELL_BURIED.resize(p_s,false);
    atom_i.ACCESSIBLE_P = p_s;
    atom_i.SHELL.resize(p_s3);
    auto R_I = atom_i.RADIUS;
    auto* C = atom_i.COORDS.data();
    auto* s = atom_i.SHELL.data();
    for(uint32 j = 0; j < p_s3; ++j){
      s[j] = p[j] * R_I + C[j%3];
    }
  }
}


void VDWcontainer::GenPoints(string pfile){
/*  //golden spiral
    Result.resize(N * 3);
    uint32 N2 = N * 2;
    float inc = PI*(3.0 - sqrt(5.0));
    float off = 2.0 / (float)N;
  for (uint32 i = 0; i < N; i++){
      float y = i * off - 1.0 + (off / 2.0);
      float r = sqrt(1.0 - y*y);
      float phi = i*inc;
      Result[i] = cos(phi)*r;
      Result[i + N] = y;
      Result[i + N2] = sin(phi)*r;
    }
    return Result;
  }*/

//thomson electrostatic simulation http://thomson.phy.syr.edu/
  ifstream xyz_thomson(pfile);
  uint32 i = 0;
  string line;
  getline(xyz_thomson, line);
  auto N = stoi(line);
  Points.resize(N * 3);
  while (xyz_thomson.good()){
    getline(xyz_thomson, line);
    istringstream buffer(line);
    vector<string> tokens((istream_iterator<string>(buffer)), istream_iterator<string>());
    if (tokens.size() == 3){
      //row order, keeps vector access local [x + y*3].
      Points[i]     = stod(tokens[0]);
      Points[1 + i] = stod(tokens[1]);
      Points[2 + i] = stod(tokens[2]);
      i+=3;
    }
  }
  xyz_thomson.close();
}
void VDWcontainer::GenPoints(){
  Points = p15k;
}
void VDWcontainer::GenPoints(int select){
  if (select == 0)  Points = p15k;
  else Points = p2k;
}

VDWcontainer::~VDWcontainer(void)
{
}
class VDWcontainer
{
public:
  VDWcontainer(string);
  VDWcontainer();
  void load_data(vector<vector<string>>);

  void SetRadius(vector<atom_struct>&,float);
  void SetShell(vector<atom_struct>&);
  void GenPoints(int);
  void GenPoints(string);
  void GenPoints();
  string CorrectRESN(string);
  ~VDWcontainer(void);
    vector<float> Points;
private:
const bool Mol2ext = true;
string pdbradii = R"pdb(PDB_RADIUS_FILE
ATOM	CBC	1.90	0	
ATOM	N D	1.55	1	
ATOM	C1D	1.78	0	
ATOM	C2D	1.78	0	
ATOM	C3D	1.78	0	
ATOM	C4D	1.78	0	
ATOM	CMD	1.90	0	
ATOM	CAD	1.90	0	
ATOM	CBD	1.90	0	
ATOM	CGD	1.90	0	
ATOM	O1A	1.35	1	
ATOM	O2A	1.35	1	
ATOM	O1D	1.35	1	
ATOM	O2D	1.35	1	
RESIDUE	WATER	HOH	1
ATOM	O	1.40	1)pdb";


string mol2radii = R"mol2(MOL2_RADIUS_FILE
SYBYL	C.3	1.88	0
SYBYL	C.2	1.76	0
SYBYL	C.ar	1.61	0
SYBYL	C.1	1.88	0
SYBYL	C.cat	1.61	1
SYBYL	N.4	1.64	1
SYBYL	N.3	1.64	1
SYBYL	N.2	1.64	1
SYBYL	N.pl3	1.64	1
SYBYL	N.1	1.64	1
SYBYL	N.am	1.64	1
SYBYL	N.ar	1.64	1
SYBYL	O.3	1.46	1
SYBYL	O.2	1.42	1
SYBYL	O.co2	1.46	1
SYBYL	O	1.46	1
SYBYL	S.3	1.77	0
SYBYL	S.2	1.77	0
SYBYL	S.O2	1.77	0
SYBYL	S.O	1.77	0
SYBYL	S.o2	1.77	0
SYBYL	S.o	1.77	0
SYBYL	H    	1.00	0
SYBYL	P.3	1.871	1
SYBYL	Cl	1.736	0
SYBYL	F	1.560	0
SYBYL	Br	1.978	0
SYBYL	I	2.094	0)mol2";
  map<string, map<string,float>> Map;
  map<string, map<string,int >> MapPolarity;
  map<string,float> u_vdw_radii;
  map<string,int> u_vdw_radii_polarity;


  const vector<float> p15k = { 0.52574281614927, 0.8506435740611963, 3.429036428056331E-5,
-0.5364626722559406, 0.8435207524270372,-0.02608719036118334,
-0.863833282794613, 0.01358177091968806, 0.5035946733584135,
-0.5257555574424573,-0.8506356995515844, 2.1604576015887832E-5,
-0.5036013448401081,-0.8638304079818688,-0.013517089964669462,
-0.8638462347209346,-0.013543432614653784,-0.5035734883723294,
 0.8978381706279807, 0.07526721966544082, 0.4338449780823046,
 
// or project specific include files that are used frequently, but
// are changed infrequently
//
typedef unsigned int uint;
typedef unsigned int uint32;
typedef unsigned long long uint64;
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <vector>
#include <string>
#include <map>
#include <fstream>
#include <sstream>
#include <iterator>
#include <algorithm>
#include <utility>
#include <functional>
#include <tuple>
#include <set>
#include <numeric>
#include <queue>
#include <stdexcept>
#include <regex>
#define PI 3.1415926f
using namespace std;
