import os
import sys
import platform
import sysconfig
from pathlib import Path

def get_lib_paths():
    """Dynamically generate possible library paths based on current platform and Python version"""
    root_dir = Path(__file__).parent.parent
    
    # Get Python implementation and version info
    implementation = platform.python_implementation().lower()
    version = sysconfig.get_config_var('py_version_nodot')
    full_version = sysconfig.get_config_var('py_version_nodot_plat')
    
    # Get platform-specific info
    system = platform.system().lower()
    machine = platform.machine().lower()
    
    # Base paths that always should be checked
    paths = [
        root_dir / "build" / "lib",
        root_dir / "build"
    ]
    
    # Platform specific path construction
    if system == 'linux':
        platform_tag = f"linux-{machine}"
    elif system == 'darwin':
        platform_tag = f"macosx-{machine}"
    elif system == 'windows':
        platform_tag = f"win-{machine}"
    else:
        platform_tag = f"{system}-{machine}"
    
    # Add platform-specific paths
    lib_patterns = [
        f"lib.{platform_tag}-{implementation}-{version}",
        f"lib.{platform_tag}-{implementation}{version}",
        f"lib.{platform_tag}-{full_version}",
        f"lib.{platform_tag}",
        f"lib.{system}-{machine}",
    ]
    
    # Add all possible combinations
    for pattern in lib_patterns:
        paths.append(root_dir / "build" / pattern)
    
    # Print debug info if needed
    if os.environ.get('DEBUG'):
        print(f"Python Implementation: {implementation}")
        print(f"Python Version: {version}")
        print(f"Platform: {platform_tag}")
        print("Checking paths:")
        for path in paths:
            print(f"  {path}")
    
    return paths

def pytest_sessionstart(session):
    """Add library paths to sys.path at the start of testing"""
    paths = get_lib_paths()
    
    # Add all existing build paths to sys.path
    added_paths = []
    for build_path in paths:
        if build_path.exists():
            build_path_str = str(build_path.absolute())
            if build_path_str not in sys.path:
                sys.path.insert(0, build_path_str)
                added_paths.append(build_path_str)
    
    if added_paths:
        print("\nAdded build paths:")
        for path in added_paths:
            print(f"  ✓ {path}")
    else:
        print("\nWarning: No valid build paths found!")
        print("Searched in:")
        for path in paths:
            print(f"  ✗ {path}")import pytest
import os
import sys
from pathlib import Path
import numpy as np
import dr_sasa_py as sasa
from bindings.python.utils.structure_parser import StructureData, parse_pdb_file, superimpose_structures

# Test data
@pytest.fixture
def sample_atom_data():
    return {
        'atom_positions': np.array([  # Changed from 'positions' to 'atom_positions'
            [0.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [2.0, 0.0, 0.0],
            [3.0, 0.0, 0.0]
        ]),
        'atom_names': np.array(['N', 'CA', 'C', 'O']),
        'residue_names': np.array(['ALA', 'ALA', 'ALA', 'ALA']),
        'residue_numbers': np.array([1, 1, 1, 1]),
        'chain_ids': np.array(['A', 'A', 'A', 'A']),
        'elements': np.array(['N', 'C', 'C', 'O']),
        'occupancies': np.ones(4),
        'b_factors': np.zeros(4),
        'atom_masks': np.ones(4),
        'alt_locs': np.array([''] * 4),
        'insertion_codes': np.array([''] * 4),
        'charges': np.array([''] * 4)
    }

def create_test_atom():
    """Helper function to create a test atom"""
    return sasa.AtomStruct(
        id=1,
        resi=1,
        icode="",
        name="CA",
        resn="ALA",
        chain="A",
        element="C",
        structure="",
        mol_type="PROTEIN",
        x=0.0,
        y=0.0,
        z=0.0,
        altloc="",
        occupancy=1.0,
        tfactor=0.0,
        charge=""
    )

def test_atom_struct():
    atom = create_test_atom()
    assert atom.ID == 1
    assert atom.NAME == "CA"
    assert atom.RESN == "ALA"
    assert atom.CHAIN == "A"
    assert atom.RESI == 1
    assert list(atom.COORDS) == [0.0, 0.0, 0.0]  # Convert tuple to list for comparison

def test_atom_struct_coordinates():
    atom = create_test_atom()
    # Test setting coordinates
    atom.COORDS = [1.0, 2.0, 3.0]
    assert list(atom.COORDS) == [1.0, 2.0, 3.0]  # Convert tuple to list for comparison
    
    # Test error on wrong number of coordinates
    with pytest.raises(RuntimeError):
        atom.COORDS = [1.0, 2.0]  # Should fail - needs 3 coordinates

def test_structure_data_creation(sample_atom_data):
    structure = StructureData(**sample_atom_data, structure_id="test")
    assert len(structure.atom_names) == 4
    assert structure.structure_id == "test"
    assert np.all(structure.chain_ids == 'A')

def test_structure_validation():
    # Test with invalid coordinates
    bad_data = {
        'atom_positions': np.array([[np.nan, 0.0, 0.0]]),  # Changed from 'positions'
        'atom_names': np.array(['CA']),
        'residue_names': np.array(['ALA']),
        'residue_numbers': np.array([1]),
        'chain_ids': np.array(['A']),
        'elements': np.array(['C']),
        'occupancies': np.ones(1),
        'b_factors': np.zeros(1),
        'atom_masks': np.ones(1),
        'alt_locs': np.array([''] * 1),
        'insertion_codes': np.array([''] * 1),
        'charges': np.array([''] * 1)
    }
    
    with pytest.warns(UserWarning):
        structure = StructureData(**bad_data)
        assert np.all(np.isfinite(structure.atom_positions))

def test_coordinate_transformation(sample_atom_data):
    structure = StructureData(**sample_atom_data)
    
    # Test centering
    centered = structure.transform_coordinates(center=True)
    assert np.allclose(np.mean(centered.atom_positions, axis=0), 0.0)
    
    # Test rotation
    rotation = np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]])  # 90° around z
    rotated = structure.transform_coordinates(rotation=rotation)
    assert np.allclose(rotated.atom_positions[1], [0.0, 1.0, 0.0])

def test_atom_selection(sample_atom_data):
    structure = StructureData(**sample_atom_data)
    
    # Select CA atoms
    ca_mask = structure.atom_names == 'CA'
    ca_struct = structure.select_atoms(ca_mask)
    assert len(ca_struct.atom_names) == 1
    assert ca_struct.atom_names[0] == 'CA'

# Existing tests
def test_pdb_parsing():
    if not os.path.exists("tests/data/3i40.pdb"):
        pytest.skip("Test PDB file not found")
    structure = parse_pdb_file("tests/data/3i40.pdb")
    assert len(structure.atom_names) > 0
    assert np.all(np.isfinite(structure.atom_positions))
    assert np.all(structure.occupancies > 0)

def test_simple_sasa_creation():
    calc = sasa.SimpleSASA()
    assert calc is not None
    
    calc_custom = sasa.SimpleSASA(probe_radius=1.2)
    assert calc_custom is not None

@pytest.mark.skipif(not os.path.exists("tests/data/3i40.pdb"), reason="Test PDB file not found")
def test_simple_sasa_calculation():
    calc = sasa.SimpleSASA()
    results = calc.calculate("tests/data/3i40.pdb")
    assert isinstance(results, dict)
    assert len(results) > 0

def test_structure_superposition(sample_atom_data):
    structure = StructureData(**sample_atom_data)
    
    # Add small random displacement to create second structure
    displaced = structure.transform_coordinates(
        translation=np.array([1.0, 2.0, -1.0]),
        rotation=np.eye(3)
    )
    
    # Superimpose
    aligned = superimpose_structures(displaced, structure)
    
    # Check RMSD is small
    rmsd = np.sqrt(np.mean(np.sum((aligned.atom_positions - 
                                  structure.atom_positions)**2, axis=1)))
    assert rmsd < 1e-10

if __name__ == "__main__":
    pytest.main([__file__, "-v"])import pytest
from pathlib import Path
import numpy as np
from typing import List, Optional, Dict, Any
import dr_sasa_py
from bindings.python.utils.structure_parser import StructureData, parse_pdb_file
import warnings

# Constants
TEST_DATA_DIR = Path(__file__).parent / "data"
TEST_FILES = {
    "basic": "3i40.pdb",
    #"complex": "6gwp.pdb",
    #"prediction": "pred.pdb" 
}

def get_test_file(key: str) -> Path:
    """Get path to test file, skip if not found"""
    path = TEST_DATA_DIR / TEST_FILES[key]
    if not path.exists():
        pytest.skip(f"Test file not found: {path}")
    return path

def validate_sasa_results(results: Dict[str, Any], calc_type: str = "simple") -> None:
    """Validate SASA calculation results structure and data types."""
    # Validate top-level structure
    assert isinstance(results, dict), "Results must be a dictionary"
    required_keys = {"atom_data", "residue_data"}  # residue_index is optional
    missing_keys = required_keys - set(results.keys())
    assert not missing_keys, f"Missing top-level keys: {missing_keys}"

    # Validate atom data
    atom_data = results["atom_data"]
    assert isinstance(atom_data, dict), "atom_data must be a dictionary"
    assert len(atom_data) > 0, "atom_data cannot be empty"

    # Get first atom entry for detailed validation
    first_atom_id = next(iter(atom_data))
    first_atom = atom_data[first_atom_id]

    # Validate atom data structure and types based on actual implementation
    required_atom_fields = {
        "name": str,          # NAME in C++
        "resname": str,       # RESN in C++
        "chain": str,         # CHAIN in C++
        "resid": int,         # RESI in C++
        "struct_type": str,   # STRUCT_TYPE in C++
        "coords": tuple,      # COORDS in C++
        "sphere_area": float, # AREA in C++
        "sasa": float,        # SASA in C++
        "polar": int,         # POLAR in C++, initialized as 0
        "charge": str        # CHARGE in C++, string from PDB
    }

    missing_atom_fields = required_atom_fields.keys() - set(first_atom.keys())
    assert not missing_atom_fields, f"Missing atom fields: {missing_atom_fields}"

    # Validate atom field types
    for field, expected_type in required_atom_fields.items():
        assert isinstance(first_atom[field], expected_type), \
            f"Atom field {field} should be {expected_type}, got {type(first_atom[field])}"
        
        # Additional validation for specific fields
        if field == "polar":
            assert first_atom[field] in (0, 1), f"polar must be 0 or 1, got {first_atom[field]}"
        elif field == "coords":
            assert len(first_atom[field]) == 3, "coords must be a 3-tuple"
            assert all(isinstance(x, (int, float)) for x in first_atom[field]), \
                "coords must contain numeric values"
        elif field in ("sphere_area", "sasa"):
            assert first_atom[field] >= 0, f"{field} must be non-negative"

    # Validate residue data
    residue_data = results["residue_data"]
    assert isinstance(residue_data, list), "residue_data must be a list"
    assert len(residue_data) > 0, "residue_data cannot be empty"

    first_residue = residue_data[0]
    required_residue_fields = {
        "chain": str,
        "resname": str,
        "resid": int,
        "total_sasa": float,
        "total_area": float,
        "n_atoms": int,
        "center": tuple,
        "contacts": dict,
        "overlaps": list
    }

    missing_residue_fields = required_residue_fields.keys() - set(first_residue.keys())
    assert not missing_residue_fields, f"Missing residue fields: {missing_residue_fields}"

    # Validate residue field types and values
    for field, expected_type in required_residue_fields.items():
        assert isinstance(first_residue[field], expected_type), \
            f"Residue field {field} should be {expected_type}, got {type(first_residue[field])}"

        if field == "center":
            assert len(first_residue[field]) == 3, "center must be a 3-tuple"
            assert all(isinstance(x, (int, float)) for x in first_residue[field]), \
                "center coordinates must be numeric"
        elif field in ("total_sasa", "total_area"):
            assert first_residue[field] >= 0, f"{field} must be non-negative"
        elif field == "n_atoms":
            assert first_residue[field] > 0, "n_atoms must be positive"

    # Validate contacts if present
    if first_residue["contacts"]:
        first_contact = next(iter(first_residue["contacts"].values()))
        required_contact_fields = {
            "struct_type": str,
            "contact_area": float,
            "distance": float
        }
        
        missing_contact_fields = required_contact_fields.keys() - set(first_contact.keys())
        assert not missing_contact_fields, f"Missing contact fields: {missing_contact_fields}"
        
        for field, expected_type in required_contact_fields.items():
            assert isinstance(first_contact[field], expected_type), \
                f"Contact field {field} should be {expected_type}, got {type(first_contact[field])}"
            if field in ("contact_area", "distance"):
                assert first_contact[field] >= 0, f"{field} must be non-negative"

    # Validate overlaps if present
    if first_residue["overlaps"]:
        first_overlap = first_residue["overlaps"][0]
        required_overlap_fields = {
            "atoms": list,
            "overlap_area": float,
            "normalized_area": float,
            "buried_area": float
        }
        
        missing_overlap_fields = required_overlap_fields.keys() - set(first_overlap.keys())
        assert not missing_overlap_fields, f"Missing overlap fields: {missing_overlap_fields}"
        
        for field, expected_type in required_overlap_fields.items():
            assert isinstance(first_overlap[field], expected_type), \
                f"Overlap field {field} should be {expected_type}, got {type(first_overlap[field])}"
            
            if field == "atoms":
                assert len(first_overlap[field]) >= 2, "overlap must involve at least 2 atoms"
            elif field == "normalized_area":
                assert 0 <= first_overlap[field] <= 1, "normalized_area must be between 0 and 1"
            else:
                assert first_overlap[field] >= 0, f"{field} must be non-negative"

    # Optional validation for residue_index if present
    if "residue_index" in results:
        residue_index = results["residue_index"]
        assert isinstance(residue_index, dict), "residue_index must be a dictionary"
        assert len(residue_index) == len(residue_data), \
            "residue_index must match residue_data length"

        for res_id, idx in residue_index.items():
            assert isinstance(res_id, str), "residue_index keys must be strings"
            assert isinstance(idx, int), "residue_index values must be integers"
            assert 0 <= idx < len(residue_data), "residue_index values must be valid indices"

            # Validate key format and cross-reference
            parts = res_id.split('_')
            assert len(parts) == 3, "residue ID must have format 'chain_resname_resid'"
            
            residue = residue_data[idx]
            expected_id = f"{residue['chain']}_{residue['resname']}_{residue['resid']}"
            assert res_id == expected_id, \
                f"residue_index key {res_id} doesn't match residue data {expected_id}"

    # Calculator-specific validations
    if calc_type in ["generic", "decoupled"]:
        # Only check for presence of fields, not content
        assert "contacts" in first_residue, f"Advanced calculator {calc_type} must have contacts field"
        assert "overlaps" in first_residue, f"Advanced calculator {calc_type} must have overlaps field"
            
class TestDrSasa:
    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test environment"""
        self.probe_radius = 1.4
        self.calculators = {
            "simple": dr_sasa_py.SimpleSASA(probe_radius=self.probe_radius),
            "generic": dr_sasa_py.GenericSASA(probe_radius=self.probe_radius),
            "decoupled": dr_sasa_py.DecoupledSASA(probe_radius=self.probe_radius)
        }

    @pytest.mark.basic
    def test_atom_struct(self):
        """Test AtomStruct creation and properties"""
        atom = dr_sasa_py.AtomStruct(
            id=1, resi=1, icode="", name="CA", resn="ALA",
            chain="A", element="C", structure="test",
            mol_type="PROTEIN", x=0.0, y=0.0, z=0.0
        )
        
        assert atom.ID == 1
        assert atom.NAME == "CA"
        assert atom.RESN == "ALA"
        assert list(atom.COORDS) == [0.0, 0.0, 0.0]

    @pytest.mark.basic
    def test_structure_data(self):
        """Test StructureData creation and manipulation"""
        pdb_path = get_test_file("basic")
        structure = parse_pdb_file(pdb_path)
        assert len(structure.atom_names) > 0
        assert np.all(np.isfinite(structure.atom_positions))

    @pytest.mark.calculation
    @pytest.mark.parametrize("calc_type", ["simple", "generic"])
    def test_sasa_calculation(self, calc_type):
        """Test SASA calculation with different calculators"""
        calculator = self.calculators[calc_type]
        pdb_path = get_test_file("basic")
        
        # Basic calculation
        results = calculator.calculate(str(pdb_path))
        validate_sasa_results(results, calc_type)
        
        if calc_type in ["generic", "decoupled"]:
            try:
                # Test with chain selection
                chain_results = calculator.calculate(
                    str(pdb_path),
                    chains=[["A"], ["B"]],
                    include_matrix=True
                )
                
                # First validate the results
                validate_sasa_results(chain_results, calc_type)
                
                # Then check for chain-specific results - modify to handle actual structure
                if "atom_data" in chain_results:
                    chains_found = set()
                    for atom_id, atom_data in chain_results["atom_data"].items():
                        if "chain" in atom_data:
                            chains_found.add(atom_data["chain"])
                    
                    assert any(chain in chains_found for chain in ["A", "B"]), \
                        f"Expected chains A or B in results, found: {chains_found}"
                
                # Verify contacts (if they exist)
                has_contacts = False
                for residue in chain_results.get("residue_data", []):
                    if residue.get("contacts", {}):
                        has_contacts = True
                        break
                
                # If we expect contacts but don't find any, we can warn instead of fail
                if not has_contacts:
                    warnings.warn(f"No contacts found between chains for {calc_type} calculator")
                    
            except IndexError as e:
                pytest.xfail(f"Chain selection not fully implemented: {str(e)}")

    @pytest.mark.output
    @pytest.mark.parametrize("calc_type", ["simple", "generic"])
    def test_output_generation(self, calc_type, tmp_path):
        """Test output file generation"""
        calculator = self.calculators[calc_type]
        pdb_path = get_test_file("basic")
        
        output_name = str(tmp_path / "test_output")
        results = calculator.calculate(
            str(pdb_path),
            print_output=True,
            output_name=output_name
        )
        
        validate_sasa_results(results, calc_type)
        
        # Check for output files
        expected_files = []
        if calc_type == "simple":
            expected_files.extend([
                f"{output_name}.asa.pdb",
                f"{output_name}.atmasa"
            ])
        elif calc_type in ["generic", "decoupled"]:
            expected_files.extend([
                f"{output_name}.dsasa.pdb",
                f"{output_name}.datmasa",
                f"{output_name}.overlaps"
            ])
            
        # Verify at least some output files were created
        output_files = list(tmp_path.glob("*"))
        assert len(output_files) > 0, "No output files generated"

def pytest_configure(config):
    """Register custom markers"""
    config.addinivalue_line("markers", "basic: Basic functionality tests")
    config.addinivalue_line("markers", "calculation: SASA calculation tests")
    config.addinivalue_line("markers", "advanced: Advanced feature tests")
    config.addinivalue_line("markers", "output: Output generation tests")import pytest
import os, sys
from pathlib import Path

def test_import():
    """Test different ways to import the module"""
    import_methods = []
    
    # Method 1: Direct import
    try:
        import dr_sasa_py
        import_methods.append("Direct import successful")
    except ImportError as e:
        print(f"Direct import failed: {e}")

    # Method 2: From import all SASA classes
    try:
        from dr_sasa_py import SimpleSASA, GenericSASA, DecoupledSASA
        import_methods.append("From import SASA classes successful")
    except ImportError as e:
        print(f"From import SASA classes failed: {e}")

    # Method 3: Import using importlib
    try:
        import importlib
        dr_sasa = importlib.import_module('dr_sasa_py')
        import_methods.append("Importlib import successful")
    except ImportError as e:
        print(f"Importlib import failed: {e}")

    # Method 4: Try importing with full path
    try:
        import os
        module_path = os.path.join(os.path.dirname(__file__), '..', 'build', 'lib')
        if module_path not in sys.path:
            sys.path.append(module_path)
        import dr_sasa_py as dr_sasa_full_path
        import_methods.append("Full path import successful")
    except ImportError as e:
        print(f"Full path import failed: {e}")

    # Print successful methods
    print("\nSuccessful import methods:")
    for method in import_methods:
        print(f"✓ {method}")

    # Assert at least one method worked
    assert len(import_methods) > 0, "No import methods succeeded"

if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])  # -s flag to show print statementsimport pytest
import os
import numpy as np
from pathlib import Path
from dr_sasa_py import SimpleSASA, GenericSASA, DecoupledSASA
from bindings.python.utils.structure_parser import StructureData, parse_pdb_file

# Get path to test PDB file
TEST_PDB = str(Path(__file__).parent / "data" / "3i40.pdb")

def test_generic_sasa_print():
    """Test GenericSASA print function and matrix generation."""
    calculator = GenericSASA()
    
    # Parse PDB file using StructureData
    structure = parse_pdb_file(TEST_PDB)
    atom_structs = structure.to_atom_structs()
    
    # Test with matrices
    results = calculator.calculate(TEST_PDB, print_output=True,
                                 include_matrix=True,
                                 output_name="generic_with_matrix.tsv")
    assert isinstance(results, dict)
    assert "inter_bsa_matrix" in results
    assert "intra_bsa_matrix" in results
    
    # Check intra matrices if present
    if "intra_matrices" in results:
        #assert all(k in intra for k in ['atom_matrix', 'residue_matrix', 'atom_labels'])
        assert isinstance(results["intra_bsa_matrix"]["atom_matrix"], np.ndarray)


@pytest.mark.skip(reason="Need to handle empty atoms case properly in C++ code")
def test_print_with_empty_atoms():
    """Test print function behavior with empty atom list."""
    calculator = SimpleSASA()
    with pytest.raises(ValueError):
        calculator.print([], "test_output")

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
from pathlib import Path
import time
import sys
sys.path.append(str("/home/alessio/dr_sasa_python/build/lib"))
sys.path.append(str("/home/alessio/dr_sasa_python/bindings/python/utils"))
import dr_sasa_py

# Constants
TEST_DATA_DIR = Path(__file__).parent / "data"
TEST_FILES = {
    "small": "pred.pdb",    # Small protein complex
    #"medium": "1bl0.pdb",   # Medium-sized protein-DNA complex
    #"large": "6gwp.pdb"     # Large complex
}

def run_sasa_profiling():
    """
    Profile SASA calculations using both SimpleSASA and GenericSASA.
    Each calculator is tested with 3 different sized structures.
    """
    probe_radius = 1.4
    
    # Initialize calculators
    calculators = {
        "simple": dr_sasa_py.SimpleSASA(probe_radius=probe_radius),
        #"generic": dr_sasa_py.GenericSASA(probe_radius=probe_radius)
    }

    # Process each test file with both calculators
    for file_size, filename in TEST_FILES.items():
        pdb_path = TEST_DATA_DIR / filename
        if not pdb_path.exists():
            print(f"Test file not found: {pdb_path}")
            continue

        print(f"\nProcessing {file_size} structure: {filename}")
        
        for calc_name, calculator in calculators.items():
            print(f"\nUsing {calc_name} calculator:")
            
            # Time the calculation
            start_time = time.time()
            
            try:
                if calc_name == "simple":
                    results = calculator.calculate(str(pdb_path))
                else:
                    # For GenericSASA, also test chain interactions
                    results = calculator.calculate(
                        str(pdb_path),
                        chains=[["A"], ["B"]],
                        include_matrix=True
                    )
                
                end_time = time.time()
                duration = end_time - start_time
                
                # Print basic statistics
                n_atoms = len(results["atom_data"])
                n_residues = len(results["residue_data"])
                print(f"Time taken: {duration:.3f} seconds")
                print(f"Atoms processed: {n_atoms}")
                print(f"Residues processed: {n_residues}")
                print(f"Processing speed: {n_atoms/duration:.1f} atoms/second")
                
            except Exception as e:
                print(f"Error processing {filename} with {calc_name}: {str(e)}")

if __name__ == "__main__":
    run_sasa_profiling() #py-spy record -o profile.svg --native --format flamegraph  --rate 100 python tests/test_profiling.py